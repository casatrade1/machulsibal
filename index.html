
</html><!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>누적 계좌내역 완전 분석 시스템</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; background: #f5f7fa; line-height: 1.6; }
        .container { max-width: 1600px; margin: 0 auto; padding: 20px; }
        
        .header { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            color: white; padding: 30px; border-radius: 15px; text-align: center; margin-bottom: 30px; 
        }
        .header h1 { margin-bottom: 10px; }
        .header-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-top: 20px; }
        .header-stat { background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; }
        .header-stat-number { font-size: 1.5em; font-weight: bold; }
        .header-stat-label { font-size: 0.9em; opacity: 0.9; }
        
        .upload-section { 
            background: white; padding: 25px; border-radius: 15px; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.1); margin-bottom: 25px; 
        }
        .file-drop { 
            border: 2px dashed #d1d5db; border-radius: 10px; padding: 40px 20px; 
            text-align: center; cursor: pointer; transition: all 0.2s; 
        }
        .file-drop:hover { border-color: #2563eb; background: #f8fafc; }
        .file-drop.active { border-color: #059669; background: #f0fdf4; }
        .file-input { display: none; }
        
        .tabs {
            display: flex; background: white; border-radius: 15px; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.1); margin-bottom: 25px; overflow: hidden;
        }
        .tab {
            padding: 15px 20px; background: #f9fafb; border: none; 
            cursor: pointer; font-weight: 500; flex: 1; transition: all 0.2s;
        }
        .tab.active { background: #2563eb; color: white; }
        .tab:hover:not(.active) { background: #e5e7eb; }
        
        .content-section { 
            background: white; border-radius: 15px; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.1); overflow: hidden; margin-bottom: 20px;
        }
        .section-header { 
            background: #f8fafc; padding: 20px; border-bottom: 1px solid #e5e7eb; 
            display: flex; justify-content: space-between; align-items: center; 
        }
        .section-title { font-size: 1.3em; font-weight: bold; color: #1f2937; }
        .section-body { padding: 20px; }
        
        .summary-grid { 
            display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); 
            gap: 20px; margin-bottom: 25px; 
        }
        .summary-card { 
            background: #f9fafb; padding: 20px; border-radius: 15px; 
            border-left: 4px solid #2563eb; 
        }
        .summary-title { font-weight: bold; color: #1f2937; margin-bottom: 8px; }
        .summary-value { color: #2563eb; font-size: 1.3em; font-weight: 600; margin-bottom: 5px; }
        .summary-detail { font-size: 0.9em; color: #6b7280; }
        
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 12px 8px; text-align: left; border-bottom: 1px solid #e5e7eb; }
        th { 
            background: #f9fafb; font-weight: 600; color: #374151; 
            position: sticky; top: 0; z-index: 10;
        }
        td { font-size: 14px; }
        
        .amount-positive { color: #059669; font-weight: 600; }
        .amount-negative { color: #dc2626; font-weight: 600; }
        .amount-large { color: #7c3aed; font-weight: bold; }
        
        .customer-row { cursor: pointer; transition: background 0.2s; }
        .customer-row:hover { background: #f9fafb; }
        .customer-row.expanded { background: #f0fdf4; }
        
        .detail-row { 
            background: #f8fafc; font-size: 0.9em; 
            border-left: 3px solid #2563eb; 
        }
        .detail-row td { padding: 8px 12px; }
        
        .status-badge { 
            padding: 4px 12px; border-radius: 20px; font-size: 0.8em; font-weight: 600; 
        }
        .status-unreturned { background: #fef2f2; color: #dc2626; }
        .status-returned { background: #f0fdf4; color: #059669; }
        .status-refund { background: #fef2f2; color: #dc2626; }
        .status-excluded { background: #fef3c7; color: #d97706; }
        .status-new { background: #ede9fe; color: #7c3aed; }
        .status-sales { background: #dbeafe; color: #2563eb; }
        .status-deposit { background: #fef3c7; color: #d97706; }
        
        .btn { 
            background: #2563eb; color: white; padding: 12px 24px; 
            border: none; border-radius: 8px; cursor: pointer; 
            font-weight: 500; transition: all 0.2s; margin: 0 5px;
        }
        .btn:hover { background: #1d4ed8; }
        .btn-secondary { background: #6b7280; }
        .btn-secondary:hover { background: #4b5563; }
        
        .search-filter {
            display: flex; gap: 15px; margin-bottom: 20px; align-items: center;
        }
        .search-input {
            padding: 10px 15px; border: 1px solid #d1d5db; border-radius: 8px; 
            font-size: 14px; flex: 1; max-width: 300px;
        }
        
        .notification { 
            position: fixed; top: 20px; right: 20px; background: #059669; 
            color: white; padding: 15px 20px; border-radius: 8px; z-index: 1000; 
            transform: translateX(300px); transition: transform 0.3s ease; 
        }
        .notification.show { transform: translateX(0); }
        
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .progress-bar {
            background: #e5e7eb; height: 4px; border-radius: 2px; overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            background: #2563eb; height: 100%; transition: width 0.3s ease;
        }
        
        .transaction-type-income { background: #f0fdf4; }
        .transaction-type-outcome { background: #fef2f2; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📊 누적 계좌내역 완전 분석 시스템</h1>
            <p>전체 계좌내역 누적 분석 • 매출/보증금/환급 완전 추적 • 상세 거래내역 확인</p>
            <div class="header-stats">
                <div class="header-stat">
                    <div class="header-stat-number" id="totalTransactions">0건</div>
                    <div class="header-stat-label">총 거래 건수</div>
                </div>
                <div class="header-stat">
                    <div class="header-stat-number" id="totalIncome">₩0</div>
                    <div class="header-stat-label">총 입금액</div>
                </div>
                <div class="header-stat">
                    <div class="header-stat-number" id="totalCustomers">0명</div>
                    <div class="header-stat-label">전체 고객 수</div>
                </div>
                <div class="header-stat">
                    <div class="header-stat-number" id="finalSalesAmount">₩0</div>
                    <div class="header-stat-label">최종 매출액</div>
                </div>
            </div>
        </div>

        <div class="upload-section">
            <div class="file-drop" id="fileDrop">
                <h3>📂 계좌내역 업로드 (누적 분석)</h3>
                <p>새로운 계좌내역을 업로드하면 기존 데이터에 추가로 누적됩니다</p>
                <div id="uploadStatus"></div>
                <input type="file" id="fileInput" class="file-input" accept=".xlsx,.xls">
            </div>
            <div style="display: flex; gap: 15px; margin-top: 20px; align-items: center;">
                <button onclick="analyzeData()" class="btn" id="analyzeBtn" disabled>🔍 전체 데이터 분석</button>
                <button onclick="clearData()" class="btn btn-secondary">🗑️ 데이터 초기화</button>
                <button onclick="exportData()" class="btn btn-secondary">📊 분석 결과 내보내기</button>
                <div id="processStatus" style="flex: 1; text-align: right;"></div>
            </div>
            <div class="progress-bar" id="progressContainer" style="display: none;">
                <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="showTab('ceoDashboard')">📊 CEO 대시보드</button>
            <button class="tab" onclick="showTab('deposits')">🏦 보증금 관리</button>
            <button class="tab" onclick="showTab('tradeSales')">🏪 트레이드 매출</button>
            <button class="tab" onclick="showTab('boutiqueSales')">🛍️ 부티크 매출</button>
            <button class="tab" onclick="showTab('monthly')">📅 월별 분석</button>
            <button class="tab" onclick="showTab('transactions')">📋 전체 거래</button>
        </div>

        <!-- CEO 대시보드 탭 -->
        <div id="ceoDashboard" class="content-section tab-content active">
            <div class="section-header">
                <div class="section-title">📊 CEO 요약 대시보드</div>
            </div>
            <div class="section-body">
                <div class="summary-grid">
                    <div class="summary-card">
                        <div class="summary-title">💰 총 보증금</div>
                        <div class="summary-value" id="ceoDashboardTotalDeposits">₩0</div>
                        <div class="summary-detail" id="ceoDashboardDepositDetail">미환급 + 환급완료</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-title">📈 총 매출</div>
                        <div class="summary-value" id="ceoDashboardTotalSales">₩0</div>
                        <div class="summary-detail" id="ceoDashboardSalesDetail">트레이드 + 부티크</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-title">⚠️ 이탈 위험 고객</div>
                        <div class="summary-value" id="ceoDashboardRiskCustomers">0명</div>
                        <div class="summary-detail" id="ceoDashboardRiskDetail">보증금 있으나 매출 없음</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-title">📊 보증금 효율성</div>
                        <div class="summary-value" id="ceoDashboardEfficiency">0%</div>
                        <div class="summary-detail" id="ceoDashboardEfficiencyDetail">매출 대비 보증금 비율</div>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 30px;">
                    <div style="background: #f9fafb; padding: 20px; border-radius: 10px;">
                        <h4 style="margin-bottom: 15px;">📈 월별 성장 비교</h4>
                        <div id="monthlyGrowthChart"></div>
                    </div>
                    <div style="background: #f9fafb; padding: 20px; border-radius: 10px;">
                        <h4 style="margin-bottom: 15px;">👥 고객 성장 패턴</h4>
                        <div id="customerGrowthChart"></div>
                    </div>
                </div>

                <div style="margin-top: 30px;">
                    <h4 style="margin-bottom: 15px;">⚠️ 이탈 위험 고객 목록</h4>
                    <div id="riskCustomersList"></div>
                </div>

                <div id="recentUploads" style="margin-top: 30px;">
                    <h4 style="margin-bottom: 15px;">📂 업로드된 파일 현황</h4>
                    <div id="uploadHistory"></div>
                </div>
            </div>
        </div>

        <!-- 보증금 관리 탭 -->
        <div id="deposits" class="content-section tab-content">
            <div class="section-header">
                <div class="section-title">🏦 보증금 관리</div>
                <div class="search-filter">
                    <input type="text" id="depositSearch" class="search-input" placeholder="고객명 검색...">
                    <select id="depositFilter" class="search-input" style="max-width: 150px;">
                        <option value="all">전체 보증금</option>
                        <option value="active">현재 유지고객</option>
                        <option value="returned">이탈고객(환급완료)</option>
                        <option value="large">고액 (500만+)</option>
                    </select>
                    <select id="depositSort" class="search-input" style="max-width: 120px;">
                        <option value="deposit_desc">보증금↓</option>
                        <option value="deposit_asc">보증금↑</option>
                        <option value="date_desc">최신순</option>
                        <option value="date_asc">오래된순</option>
                        <option value="deposit_date_desc">보증금입금순(최신)</option>
                        <option value="deposit_date_asc">보증금입금순(오래된)</option>
                    </select>
                </div>
            </div>
            <div class="section-body">
                <div class="summary-grid">
                    <div class="summary-card">
                        <div class="summary-title">🔴 미환급 보증금</div>
                        <div class="summary-value" id="unreturnedDepositAmount">₩0</div>
                        <div class="summary-detail" id="unreturnedDepositCount">0명 고객</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-title">✅ 환급완료 보증금</div>
                        <div class="summary-value" id="returnedDepositAmount">₩0</div>
                        <div class="summary-detail" id="returnedDepositCount">0명 고객</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-title">📊 보증금 효율성</div>
                        <div class="summary-value" id="depositEfficiency">0%</div>
                        <div class="summary-detail" id="depositEfficiencyDetail">매출 전환율</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-title">⚠️ 주의 고객</div>
                        <div class="summary-value" id="warningCustomers">0명</div>
                        <div class="summary-detail" id="warningCustomersDetail">보증금만 있고 매출 없음 (미환급)</div>
                    </div>
                </div>
                
                <table id="depositsTable">
                    <thead>
                        <tr>
                            <th>고객명</th>
                            <th>보증금</th>
                            <th>보증금 날짜</th>
                            <th>환급상태</th>
                            <th>환급일</th>
                            <th>매출</th>
                            <th>비고</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <!-- 트레이드 매출 분석 탭 -->
        <div id="tradeSales" class="content-section tab-content">
            <div class="section-header">
                <div class="section-title">🏪 트레이드 매출 거래내역 (최신순)</div>
                <div class="search-filter">
                    <input type="text" id="tradeSearch" class="search-input" placeholder="고객명 검색...">
                    <select id="tradeFilter" class="search-input" style="max-width: 200px;">
                        <option value="all">전체 트레이드</option>
                        <option value="high">고액 (500만+)</option>
                        <option value="medium">중액 (100만+)</option>
                        <option value="low">소액 (100만미만)</option>
                        <option value="recent">최근 7일</option>
                    </select>
                    <select id="tradeSort" class="search-input" style="max-width: 120px;">
                        <option value="date_desc">최신순</option>
                        <option value="amount_desc">금액↓</option>
                        <option value="amount_asc">금액↑</option>
                        <option value="customer_asc">고객명순</option>
                    </select>
                </div>
            </div>
            <div class="section-body">
                <div class="summary-grid" id="tradeSummaryGrid">
                    <div class="summary-card">
                        <div class="summary-title">🏪 총 트레이드 매출</div>
                        <div class="summary-value" id="totalTradeRevenue">₩0</div>
                        <div class="summary-detail" id="totalTradeCount">0건 거래</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-title">📅 오늘 매출</div>
                        <div class="summary-value" id="todayTradeRevenue">₩0</div>
                        <div class="summary-detail" id="todayTradeCount">0건 거래</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-title">🔥 이번주 매출</div>
                        <div class="summary-value" id="weekTradeRevenue">₩0</div>
                        <div class="summary-detail" id="weekTradeCount">0건 거래</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-title">📈 평균 거래액</div>
                        <div class="summary-value" id="avgTradeAmount">₩0</div>
                        <div class="summary-detail" id="avgTradeDetail">거래당 평균</div>
                    </div>
                </div>
                
                <table id="tradeTable">
                    <thead>
                        <tr>
                            <th>거래일시</th>
                            <th>고객명</th>
                            <th>매출액</th>
                            <th>거래타입</th>
                            <th>누적매출</th>
                            <th>보증금상태</th>
                            <th>상세보기</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <!-- 부티크 매출 분석 탭 -->
        <div id="boutiqueSales" class="content-section tab-content">
            <div class="section-header">
                <div class="section-title">🛍️ 부티크 매출 분석</div>
                <div class="search-filter">
                    <input type="text" id="boutiqueSearch" class="search-input" placeholder="고객명 검색...">
                    <select id="boutiqueFilter" class="search-input" style="max-width: 200px;">
                        <option value="all">전체 부티크</option>
                        <option value="high">고매출 (200만+)</option>
                        <option value="medium">중매출 (50만+)</option>
                        <option value="low">저매출 (50만미만)</option>
                    </select>
                    <select id="boutiqueSort" class="search-input" style="max-width: 120px;">
                        <option value="sales_desc">매출↓</option>
                        <option value="sales_asc">매출↑</option>
                        <option value="date_desc">최신순</option>
                        <option value="date_asc">오래된순</option>
                    </select>
                </div>
            </div>
            <div class="section-body">
                <div class="summary-grid" id="boutiqueSummaryGrid">
                    <!-- 부티크 매출 요약 정보가 여기에 동적으로 추가됩니다 -->
                </div>
                
                <table id="boutiqueTable">
                    <thead>
                        <tr>
                            <th>고객명</th>
                            <th>매출액</th>
                            <th>거래건수</th>
                            <th>거래기간</th>
                            <th>월평균</th>
                            <th>첫거래일</th>
                            <th>상세보기</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <!-- 월별 분석 탭 -->
        <div id="monthly" class="content-section tab-content">
            <div class="section-header">
                <div class="section-title">📅 월별 거래 현황</div>
            </div>
            <div class="section-body">
                <div class="summary-grid">
                    <div class="summary-card">
                        <div class="summary-title">📊 월별 분석 기준</div>
                        <div class="summary-value">순수 매출만</div>
                        <div class="summary-detail">보증금, 환급, 제외항목 완전 제외한 실제 매출 거래</div>
                    </div>
                </div>
                
                <table id="monthlyTable">
                    <thead>
                        <tr>
                            <th>년월</th>
                            <th>매출 거래건수</th>
                            <th>매출액</th>
                            <th>트레이드/부티크</th>
                            <th>신규고객</th>
                            <th>평균거래액</th>
                            <th>전월대비</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <!-- 전체 거래 탭 -->
        <div id="transactions" class="content-section tab-content">
            <div class="section-header">
                <div class="section-title">📋 전체 거래 내역 (직원 분류 가능)</div>
                <div class="search-filter">
                    <input type="text" id="transactionSearch" class="search-input" placeholder="고객명/날짜 검색...">
                    <select id="transactionFilter" class="search-input" style="max-width: 200px;">
                        <option value="all">전체</option>
                        <option value="income">입금만</option>
                        <option value="outcome">출금만</option>
                        <option value="large">100만원 이상</option>
                        <option value="recent">최근 30일</option>
                        <option value="unclassified">미분류</option>
                    </select>
                    <button class="btn" onclick="exportClassificationData()">📊 분류 데이터 내보내기</button>
                    <button class="btn btn-secondary" onclick="importClassificationData()">📥 분류 데이터 가져오기</button>
                    <button class="btn" style="background: #7c3aed;" onclick="showCustomerMergeModal()">🔗 고객 병합</button>
                </div>
            </div>
            <div class="section-body">
                <div class="summary-grid">
                    <div class="summary-card">
                        <div class="summary-title">📝 분류 완료</div>
                        <div class="summary-value" id="classifiedCount">0건</div>
                        <div class="summary-detail">전체 거래 대비 분류 완료율</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-title">⏳ 미분류</div>
                        <div class="summary-value" id="unclassifiedCount">0건</div>
                        <div class="summary-detail">분류 필요한 거래</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-title">🏪 트레이드 매출</div>
                        <div class="summary-value" id="tradeClassifiedCount">0건</div>
                        <div class="summary-detail">직원 분류 트레이드 매출</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-title">🛍️ 부티크 매출</div>
                        <div class="summary-value" id="boutiqueClassifiedCount">0건</div>
                        <div class="summary-detail">직원 분류 부티크 매출</div>
                    </div>
                </div>
                
                <table id="transactionsTable">
                    <thead>
                        <tr>
                            <th>날짜</th>
                            <th>고객명</th>
                            <th>입금액</th>
                            <th>출금액</th>
                            <th>자동분류</th>
                            <th>직원분류</th>
                            <th>비고</th>
                            <th>상태</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="notification" class="notification"></div>

    <script>
        // 전역 데이터 저장소
        let allTransactions = [];
        let allCustomers = {};
        let uploadHistory = [];
        let analysisComplete = false;
        let staffClassifications = {};
    
        // 제외 고객 및 패턴 규칙 (KB체크, 이자세금 등 매출이 아닌 거래들)
        const excludePatterns = ['황승하', '황승하(쿨키즈클럽)', 'SENTBE', '이창훈', '국고환급:은평세무서', '주식회사필웨이', 'KB체크', '체크', '마스타해외승인출금', '이자세금', '자동결제', 'Amazon_AWS', 'NICE', '달빛포차', '유채연', '구글플레이', 'GooglePlay', 'Google Play', '비대면당발송금취소'];
        const specialCases = {
            '김진호': { 
                type: 'settlement_complete', 
                note: '보증금 500만원 정산 완료',
                deposit: 5000000,
                sales: 576168,
                fee: 94071,
                refund: 4905929
            },
            '채혁': { type: 'deposit_management', note: '예치금 형태 운영' },
            '주식회사　테이밍랩(': { type: 'full_refund', note: '전액 환불' },
            '주식회사　테이밍랩': { type: 'full_refund', note: '전액 환불' },
            '테이밍랩': { type: 'full_refund', note: '전액 환불' },
            '조태련': { type: 'deposit_500', note: '500만원 보증금' },
            '주식회사디엔디(DND)': { type: 'pre_deposit', note: '예치금 형태' },
            '디엔디': { type: 'pre_deposit', note: '예치금 형태' },
            '강효순': { type: 'deposit_1000000_for_kangminguk', note: '강민국 보증금(엄마명의) - 보증금 관리에서 제외', depositAmount: 1000000, excludeFromDepositManagement: true },
            '강민국': { type: 'linked_to_kanghyosoon', note: '강효순 명의 보증금 1000만원', depositAmount: 1000000, returnDate: '2025-07-03' },
            '김선영': { type: 'deposit_2000000', note: '보증금 200만원 (100만×2회)', depositAmount: 2000000, returnDate: '2025-06-30' },
            '신수연': { type: 'partial_refund', note: '보증금 1500만원 → 1000만원 부분환급 → 잔액 500만원', 
                      totalDeposit: 15000000, partialRefund: 10000000, remainingDeposit: 5000000, 
                      refundDate: '2025-09-17' },
            '이유진': { type: 'complex_deposit_case', note: '보증금 50만원, 월이용료 차감 104,000원, 환불 1,009,475원', 
                      depositAmount: 500000, 
                      monthlyFeeDeduction: 104000,
                      actualRefund: 1009475,
                      specialCalculation: true },
            '신범수': { type: 'deposit_500000', note: '보증금 50만원', depositAmount: 500000 },
            '김유빈': { type: 'deposit_100000', note: '보증금 10만원', depositAmount: 100000 },
            '정익만': { type: 'deposit_500000', note: '보증금 50만원 (매출 있음)', depositAmount: 500000, hasSales: true },
            '정익만(쇼핑777)': { type: 'deposit_500000', note: '보증금 50만원 (매출 있음)', depositAmount: 500000, hasSales: true },
            '최재연': { type: 'deposit_500000_returned', note: '보증금 50만원 환급완료', depositAmount: 500000, returnDate: '2025-07-07' },
            '최재연(더제이명품)': { type: 'deposit_500000_returned', note: '보증금 50만원 환급완료', depositAmount: 500000, returnDate: '2025-07-07' },
            '김규': { type: 'deposit_2000000', note: '보증금 200만원 (7/14: 50만원 + 7/17: 150만원)', depositAmount: 2000000, 
                     excludeTransactions: ['2025-07-21'], depositDate: '2025-07-14' },
            '김진호': { type: 'deposit_refund_complete', note: '매출 576,168원 확정. 미결제 94,071원 상계 후 환급완료', depositAmount: 670239, returnDate: '2025-07-06', salesAmount: 576168 },
            '김미정': { type: 'deposit_2500000', note: '보증금 250만원 (8/14: 100만원 + 8/15: 150만원)', depositAmount: 2500000, 
                      depositDate: '2025-08-14' },
            '전환승': { type: 'deposit_300000', note: '보증금 30만원', depositAmount: 300000 },
            '번개장터 후루츠': { type: 'boutique_forced', note: '도소매 매출' },
            '번개장터': { type: 'boutique_forced', note: '도소매 매출' },
            '후루츠패밀리': { type: 'boutique_forced', note: '도소매 매출' },
            '장유은': { type: 'boutique_forced', note: '도소매 매출' },
            '김영주': { type: 'boutique_forced', note: '도소매 매출' }
        };
        
        // 5월 기준 환급완료 정보
        const knownRefunds = {
            '최영숙': { amount: 5000000, date: '2024-05-01' },
            '이태희': { amount: 2000000, date: '2024-05-01' },
            '김협': { amount: 2000000, date: '2024-05-01' },
            '디어빈티지': { amount: 2000000, date: '2024-05-01' },
            '디어빈티지(김수안)': { amount: 2000000, date: '2024-05-01' },
            '최재훈': { amount: 1080000, date: '2024-05-01' },
            '백기렬(빈집털이)': { amount: 1000000, date: '2024-05-01' },
            '백기렬': { amount: 1000000, date: '2024-05-01' },
            '김동범': { amount: 570000, date: '2024-05-01' },
            '김도현': { amount: 500000, date: '2024-05-01' },
            '이시훈': { amount: 230000, date: '2024-05-01' },
            '이예진': { amount: 100000, date: '2024-05-01' }
        };
    
        // 고객명 정규화 함수 (같은 사람 다른 표기 통합)
        function normalizeCustomerName(customerName) {
            if (!customerName) return customerName;
            
            let normalized = customerName.trim();
            
            // 1단계: 괄호 안의 내용 제거 (미뇽드라팡(조주윤) -> 미뇽드라팡)
            normalized = normalized.replace(/\([^)]*\)/g, '').trim();
            
            // 2단계: 뒤에 붙는 거래 관련 키워드들 제거
            const suffixPatterns = [
                /\s*(낙찰금|보증금|매출|입금|환급|출금|거래|판매|구매)\s*$/g,
                /\s*[-\s]*(낙찰|보증|매출|입금|환급|출금|거래|판매|구매)\s*$/g
            ];
            
            suffixPatterns.forEach(pattern => {
                normalized = normalized.replace(pattern, '').trim();
            });
            
            // ▼ 자동 부분환급/월이용료 차감: 직원분류가 없어도 고객 출금은 보증금에서 차감
            Object.values(allCustomers).forEach(customer => {
                if (customer.excluded) return;
                if (!customer.transactions || customer.transactions.length === 0) return;
                
                // 보증금이 감지된 고객만 처리
                if ((customer.depositAmount || 0) > 0) {
                    const customerTransactions = customer.transactions;
                    const totalCustomerOut = customerTransactions
                        .filter(t => t.type === '출금')
                        .reduce((sum, t) => sum + (t.outAmount || 0), 0);
                    
                    // 직원분류 월이용료 합계(입금/출금 어느 쪽이든 금액 사용)
                    let totalMonthlyFee = 0;
                    let totalActualRefund = 0;
                    customerTransactions.forEach(t => {
                        const tId = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                        if (staffClassifications[tId] === 'monthlyFee') {
                            totalMonthlyFee += (t.inAmount || t.outAmount || 0);
                        }
                        if (staffClassifications[tId] === 'actualRefund') {
                            totalActualRefund += (t.inAmount || t.outAmount || 0);
                        }
                    });
                    
                    const adjusted = Math.max(0, (customer.depositAmount || 0) - totalCustomerOut - totalMonthlyFee);
                    
                    // 실제 매출 계산 (총 매출 - 환불 금액)
                    if (totalActualRefund > 0) {
                        customer.salesAmount = Math.max(0, customer.totalIncome - totalActualRefund);
                    }
                    
                    // 환급완료 여부 업데이트
                    if (adjusted === 0 && totalCustomerOut > 0) {
                        customer.depositStatus = 'returned';
                        const refundTx = customerTransactions.filter(t => t.type === '출금').sort((a,b) => new Date(b.date) - new Date(a.date))[0];
                        if (refundTx) customer.returnDate = refundTx.date;
                    } else if (adjusted > 0) {
                        customer.depositStatus = 'unreturned';
                        customer.returnDate = customer.returnDate || null;
                    }
                    customer.depositAmount = adjusted;
                }
            });
            
            // 3단계: 공백과 특수문자 정리
            normalized = normalized.replace(/\s+/g, ' ').trim();
            
            // 4단계: 회사명 정리 (주식회사, (주) 등)
            normalized = normalized.replace(/^(주식회사\s*|주식회사|주\s*|㈜\s*)/g, '').trim();
            normalized = normalized.replace(/\s*（\s*$/g, '').trim(); // 전각 괄호 제거
            
            // 5단계: 최종 이름 매핑 (완전히 다른 표기법들만)
            const finalMapping = {
                '테이밍랩': '테이밍랩',
                '디엔디': '디엔디',
                'DND': '디엔디',
                '번개장터 후루츠': '번개장터',
                '후루츠패밀리': '후루츠패밀리'
            };
            
            return finalMapping[normalized] || normalized;
        }

        // 로컬 스토리지 키
        const STORAGE_KEY = 'accountAnalysisData';
    
        // 스마트한 보증금 거래 인식 함수
        function isTransactionDeposit(customer, transaction) {
            if (transaction.type !== '입금') return false;
            
            console.log(`=== 보증금 체크: ${customer.name} ===`);
            console.log('거래일:', transaction.date, '금액:', transaction.inAmount);
            console.log('고객 보증금:', customer.depositAmount, '보증금일:', customer.depositDate);
            
            // 1. 기본 보증금 거래 (첫 거래이고 100만원 이상)
            if (customer.depositAmount > 0 && transaction.inAmount === customer.depositAmount && transaction.date === customer.depositDate) {
                console.log('→ 기본 보증금 거래 인식');
                return true;
            }
            
            // 2. 특수 케이스들 자동 인식
            const specialCase = specialCases[customer.name];
            console.log('특수케이스:', specialCase);
            
            if (specialCase) {
                // 김미정: 8/14(100만) + 8/15(150만) = 250만 보증금
                if (specialCase.type === 'deposit_2500000') {
                    const isKimMijeongDeposit = (transaction.date === '2025-08-14' && transaction.inAmount === 1000000) ||
                           (transaction.date === '2025-08-15' && transaction.inAmount === 1500000);
                    console.log('→ 김미정 보증금 체크:', isKimMijeongDeposit);
                    if (isKimMijeongDeposit) return true;
                }
                
                // 김규: 7/14(50만) + 7/17(150만) = 200만 보증금
                if (specialCase.type === 'deposit_2000000') {
                    const isKimGyuDeposit = (transaction.date === '2025-07-14' && transaction.inAmount === 500000) ||
                           (transaction.date === '2025-07-17' && transaction.inAmount === 1500000);
                    console.log('→ 김규 보증금 체크:', isKimGyuDeposit);
                    if (isKimGyuDeposit) return true;
                }
                
                // 김선영: 보증금 200만원 (100만×2회)
                if (specialCase.type === 'deposit_2000000' && specialCase.depositAmount === 2000000) {
                    // 첫 2번의 100만원 거래
                    const incomeTransactions = customer.transactions
                        .filter(t => t.type === '입금')
                        .sort((a, b) => a.parsedDate - b.parsedDate);
                    const firstTwoTransactions = incomeTransactions.slice(0, 2);
                    const isFirstTwoDeposits = firstTwoTransactions.some(t => 
                        t.date === transaction.date && 
                        t.inAmount === transaction.inAmount && 
                        t.inAmount === 1000000
                    );
                    console.log('→ 김선영 보증금 체크:', isFirstTwoDeposits);
                    if (isFirstTwoDeposits) return true;
                }
                
                // 기타 지정된 보증금 금액
                if (specialCase.depositAmount && transaction.inAmount === specialCase.depositAmount) {
                    // 첫 거래인지 확인
                    const sortedTransactions = customer.transactions
                        .filter(t => t.type === '입금')
                        .sort((a, b) => a.parsedDate - b.parsedDate);
                    const isFirstTransaction = sortedTransactions[0] && 
                           sortedTransactions[0].date === transaction.date && 
                           sortedTransactions[0].inAmount === transaction.inAmount;
                    console.log('→ 기타 보증금 체크:', isFirstTransaction);
                    if (isFirstTransaction) return true;
                }
            }
            
            // 3. 일반적인 보증금 패턴 (첫 거래가 큰 금액)
            const sortedTransactions = customer.transactions
                .filter(t => t.type === '입금')
                .sort((a, b) => a.parsedDate - b.parsedDate);
            
            if (sortedTransactions[0] && 
                sortedTransactions[0].date === transaction.date && 
                sortedTransactions[0].inAmount === transaction.inAmount &&
                transaction.inAmount >= 100000) { // 10만원 이상을 보증금으로 간주
                console.log('→ 일반 보증금 패턴 인식');
                return true;
            }
            
            console.log('→ 보증금 아님');
            return false;
        }
    
        // 페이지 로드 시 초기화
        document.addEventListener('DOMContentLoaded', function() {
            initializeEventListeners();
            loadStoredData();
        });
    
        function initializeEventListeners() {
            const fileDrop = document.getElementById('fileDrop');
            const fileInput = document.getElementById('fileInput');
            
            // 파일 업로드 이벤트
            if (fileDrop && fileInput) {
                fileDrop.addEventListener('click', () => fileInput.click());
                fileDrop.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    fileDrop.classList.add('active');
                });
                fileDrop.addEventListener('dragleave', () => {
                    fileDrop.classList.remove('active');
                });
                fileDrop.addEventListener('drop', (e) => {
                    e.preventDefault();
                    fileDrop.classList.remove('active');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        handleFile(files[0]);
                    }
                });
                
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        handleFile(e.target.files[0]);
                    }
                });
            }

            // 검색 필터 이벤트 (성능 최적화 - 디바운스 적용)
            const filterElements = ['depositSearch', 'depositFilter', 'depositSort', 'tradeSearch', 'tradeFilter', 'tradeSort', 'boutiqueSearch', 'boutiqueFilter', 'boutiqueSort', 'transactionSearch', 'transactionFilter'];
            
            filterElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    // 기존 이벤트 리스너 제거 (중복 방지)
                    element.removeEventListener('input', element._filterHandler);
                    element.removeEventListener('change', element._filterHandler);
                    
                    // 디바운스된 핸들러 생성
                    element._filterHandler = debounce(() => filterTable(id), 300);
                    
                    element.addEventListener('input', element._filterHandler);
                    element.addEventListener('change', element._filterHandler);
                }
            });
        }
        
        // 디바운스 함수 (성능 최적화)
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
    
        function handleFile(file) {
            if (!file.name.match(/\.(xlsx|xls)$/)) {
                showNotification('❌ Excel 파일만 업로드 가능합니다!');
                return;
            }
            
            document.getElementById('uploadStatus').innerHTML = `
                <div style="color: #059669; margin-top: 10px;">
                    ✅ ${file.name} 선택됨 (${(file.size / 1024 / 1024).toFixed(2)}MB)
                </div>
            `;
            document.getElementById('analyzeBtn').disabled = false;
            window.uploadedFile = file;
            showNotification('📂 파일이 선택되었습니다. 분석 버튼을 클릭하세요!');
        }
    
        async function analyzeData() {
            if (!window.uploadedFile) {
                showNotification('❌ 먼저 파일을 업로드하세요!');
                return;
            }
    
            try {
                showProgress(10, '파일 읽는 중...');
                
                const reader = new FileReader();
                reader.onload = async function(e) {
                    try {
                        showProgress(30, '데이터 파싱 중...');
                        
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                        const jsonData = XLSX.utils.sheet_to_json(firstSheet, {header: 1});
                        
                        showProgress(50, '거래 내역 분석 중...');
                        
                        const newTransactions = parseTransactionData(jsonData);
                        
                        showProgress(70, '중복 제거 및 데이터 통합 중...');
                        
                        const beforeCount = allTransactions.length;
                        integrateTransactions(newTransactions);
                        const addedCount = allTransactions.length - beforeCount;
                        
                        showProgress(85, '고객별 데이터 분석 중...');
                        
                        analyzeCustomerData();
                        
                        showProgress(100, '분석 완료!');
                        
                        uploadHistory.push({
                            fileName: window.uploadedFile.name,
                            uploadTime: new Date(),
                            transactionCount: newTransactions.length,
                            addedCount: addedCount
                        });
                        
                        saveData();
                        updateAllTabs();
                        
                        analysisComplete = true;
                        showNotification(`✅ 분석 완료! ${addedCount}건의 새로운 거래가 추가되었습니다.`);
                        hideProgress();
                        
                        // 분석 완료 후 CEO 대시보드로 이동
                        showTab('ceoDashboard');
                        
                    } catch (error) {
                        console.error('분석 오류:', error);
                        showNotification('❌ 파일 분석 중 오류가 발생했습니다.');
                        hideProgress();
                    }
                };
                
                reader.readAsArrayBuffer(window.uploadedFile);
                
            } catch (error) {
                console.error('파일 읽기 오류:', error);
                showNotification('❌ 파일을 읽을 수 없습니다.');
                hideProgress();
            }
        }
    
        function parseTransactionData(jsonData) {
            const transactionData = jsonData.slice(7).filter(row => row && row.length > 5);
            
            const parsedTransactions = transactionData.map((row, index) => {
                const dateStr = row[1];
                const rawCustomer = row[2];
                const customer = normalizeCustomerName(rawCustomer); // 고객명 정규화 적용
                const outAmount = parseFloat(String(row[3]).replace(/,/g, '')) || 0;
                const inAmount = parseFloat(String(row[4]).replace(/,/g, '')) || 0;
                
                let parsedDate = null;
                if (dateStr && typeof dateStr === 'string') {
                    const dateMatch = dateStr.match(/(\d{4})\.(\d{1,2})\.(\d{1,2})/);
                    if (dateMatch) {
                        parsedDate = new Date(parseInt(dateMatch[1]), parseInt(dateMatch[2]) - 1, parseInt(dateMatch[3]));
                    }
                } else if (typeof dateStr === 'number') {
                     parsedDate = new Date((dateStr - 25569) * 86400 * 1000);
                }
                
                // 더 정확한 중복 제거를 위한 ID 생성 (시간과 순서까지 포함)
                const dateForId = parsedDate ? parsedDate.toISOString().split('T')[0] : dateStr;
                const amountForId = inAmount > 0 ? `in_${inAmount}` : `out_${outAmount}`;
                const uniqueId = `${dateForId}_${customer}_${amountForId}`;
                
                return {
                    id: uniqueId,
                    date: parsedDate ? parsedDate.toISOString().split('T')[0] : dateStr,
                    parsedDate: parsedDate,
                    customer: customer,
                    outAmount: outAmount,
                    inAmount: inAmount,
                    type: inAmount > 0 ? '입금' : '출금',
                    excluded: excludePatterns.some(exclude => customer && customer.includes(exclude))
                };
            }).filter(t => t.parsedDate && t.customer);
            
            return parsedTransactions;
        }
    
        function integrateTransactions(newTransactions) {
            const existingIds = new Set(allTransactions.map(t => t.id));
            let addedCount = 0;
            let duplicateCount = 0;
            
            newTransactions.forEach(transaction => {
                if (!existingIds.has(transaction.id)) {
                    allTransactions.push(transaction);
                    addedCount++;
                } else {
                    duplicateCount++;
                    console.log('중복 거래 발견:', transaction.date, transaction.customer, transaction.inAmount || transaction.outAmount);
                }
            });
            
            console.log(`=== 거래 통합 결과 ===`);
            console.log(`새로 추가: ${addedCount}건`);
            console.log(`중복 제외: ${duplicateCount}건`);
            console.log(`전체 거래: ${allTransactions.length}건`);
            
            allTransactions.sort((a, b) => b.parsedDate - a.parsedDate);
        }
    
        // 고객 매출 타입 분류 함수
        function classifyCustomerSalesType(customer) {
            console.log(`=== ${customer.name} 분류 분석 ===`);
            console.log('보증금:', customer.depositAmount);
            console.log('환급상태:', customer.depositStatus);
            console.log('입금 거래:', customer.transactions.filter(t => t.type === '입금').length + '건');
            console.log('첫거래일:', customer.firstTransactionDate);
            console.log('마지막거래일:', customer.lastTransactionDate);
            
            // 1. (보증금) 환급이 있는 고객 → 트레이드 매출
            if (customer.depositAmount > 0 && customer.depositStatus === 'returned') {
                console.log('→ 트레이드 (환급완료)');
                return 'trade';
            }
            
            // 2. 보증금이 있고 미환급인 경우 → 트레이드 매출 (보증금 넣고 거래 중)
            if (customer.depositAmount > 0 && customer.depositStatus === 'unreturned') {
                console.log('→ 트레이드 (미환급 보증금)');
                return 'trade';
            }
            
            // 3. 환급이 없지만 꾸준한 거래 → 트레이드 매출
            const incomeTransactions = customer.transactions.filter(t => t.type === '입금');
            const hasMultipleTransactions = incomeTransactions.length >= 3;
            const recentDate = new Date();
            recentDate.setMonth(recentDate.getMonth() - 6);
            const hasRecentTransaction = customer.lastTransactionDate && customer.lastTransactionDate > recentDate;
            
            if (hasMultipleTransactions || hasRecentTransaction) {
                console.log('→ 트레이드 (꾸준한 거래)');
                return 'trade';
            }
            
            // 4. 입금 후 오랫동안 환급 없음 → 부티크 매출
            // 1-2건 거래하고 오랫동안 환급 없는 경우
            const oneYearAgo = new Date();
            oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
            
            if (incomeTransactions.length <= 2 && customer.firstTransactionDate < oneYearAgo) {
                console.log('→ 부티크 (오래된 단발 거래)');
                return 'boutique';
            }
            
            // 5. 25년 이전 거래 위주 → 부티크 매출
            if (customer.firstTransactionDate && customer.firstTransactionDate.getFullYear() < 2025) {
                console.log('→ 부티크 (25년 이전)');
                return 'boutique';
            }
            
            // 기본값: 부티크 매출
            console.log('→ 부티크 (기본값)');
            return 'boutique';
        }

        function analyzeCustomerData() {
            allCustomers = {};
            
            allTransactions.forEach(transaction => {
                const customer = transaction.customer;
                
                if (!allCustomers[customer]) {
                    allCustomers[customer] = {
                        name: customer,
                        transactions: [],
                        totalIncome: 0,
                        totalOutcome: 0,
                        salesAmount: 0,
                        depositAmount: 0,
                        depositStatus: 'none',
                        depositDate: null,
                        returnDate: null,
                        firstTransactionDate: null,
                        lastTransactionDate: null,
                        excluded: excludePatterns.some(exclude => customer.includes(exclude))
                    };
                }
                
                const customerData = allCustomers[customer];
                customerData.transactions.push(transaction);
                
                if (transaction.type === '입금') {
                    customerData.totalIncome += transaction.inAmount;
                } else {
                    customerData.totalOutcome += transaction.outAmount;
                }
                
                if (!customerData.firstTransactionDate || transaction.parsedDate < customerData.firstTransactionDate) {
                    customerData.firstTransactionDate = transaction.parsedDate;
                }
                if (!customerData.lastTransactionDate || transaction.parsedDate > customerData.lastTransactionDate) {
                    customerData.lastTransactionDate = transaction.parsedDate;
                }
            });
            
            Object.values(allCustomers).forEach(customer => {
                if (customer.excluded) {
                    return;
                }
                
                const incomeTransactions = customer.transactions
                    .filter(t => t.type === '입금')
                    .sort((a, b) => a.parsedDate - b.parsedDate);
                
                if (incomeTransactions.length === 0) return;
                
                // 특별 케이스 먼저 처리
                if (specialCases[customer.name]) {
                    const specialCase = specialCases[customer.name];
                    
                    // ==========================================================
                    // ★★★ 정산 완료(settlement_complete) 특별 처리 로직 ★★★
                    // ==========================================================
                    if (specialCase.type === 'settlement_complete') {
                        customer.depositAmount = 0; // 최종 보증금 0원
                        customer.originalDepositAmount = specialCase.deposit; // 원래 보증금 기록
                        customer.depositStatus = 'returned'; // 환급 완료 처리
                        customer.returnDate = '2025-08-31'; // 최종 정산일 (출금일 기준)
                        customer.salesAmount = specialCase.sales; // 확정 매출
                        customer.balance = 0; // 최종 잔액 0원
                        customer.salesType = 'trade';
                        customer.note = specialCase.note;
                        return; // 다른 로직을 타지 않고 여기서 분석 종료
                    }
                    
                    // 김규 특별 처리: 200만원 보증금 (50만+150만), 낙찰금은 매출
                    if (customer.name === '김규' && specialCase.type === 'deposit_2000000') {
                        customer.depositAmount = 2000000; // 50만 + 150만
                        customer.depositDate = '2025-07-14'; // 첫 보증금 날짜
                        customer.depositStatus = 'unreturned';
                        
                        // 낙찰금(7/21)은 매출로 처리, 보증금 거래만 제외
                        let totalSales = 0;
                        customer.transactions.forEach(t => {
                            if (t.type === '입금') {
                                // 보증금 거래 제외 (7/14: 50만원, 7/17: 150만원)
                                if (t.date === '2025-07-14' && t.inAmount === 500000) return;
                                if (t.date === '2025-07-17' && t.inAmount === 1500000) return;
                                
                                // 나머지는 모두 매출 (낙찰금 포함)
                                totalSales += t.inAmount;
                            }
                        });
                        customer.salesAmount = totalSales;
                        customer.salesType = 'trade';
                        return;
                    }
                    
                    // 김미정 특별 처리: 250만원 보증금 (100만+150만)
                    if (customer.name === '김미정' && specialCase.type === 'deposit_2500000') {
                        customer.depositAmount = 2500000; // 100만 + 150만
                        customer.depositDate = '2025-08-14'; // 첫 보증금 날짜
                        customer.depositStatus = 'unreturned';
                        
                        let totalSales = 0;
                        customer.transactions.forEach(t => {
                            if (t.type === '입금') {
                                // 보증금 거래 제외 (8/14: 100만원, 8/15: 150만원)
                                if (t.date === '2025-08-14' && t.inAmount === 1000000) return;
                                if (t.date === '2025-08-15' && t.inAmount === 1500000) return;
                                
                                // 나머지는 모두 매출
                                totalSales += t.inAmount;
                            }
                        });
                        customer.salesAmount = totalSales;
                        customer.salesType = 'trade';
                        return;
                    }

                    // 김선영: 보증금 200만원 (100만×2회) 환급완료
                    if (specialCase.type === 'deposit_2000000') {
                        customer.depositAmount = specialCase.depositAmount;
                        customer.depositDate = incomeTransactions[0].date;
                        customer.depositStatus = 'returned';
                        customer.returnDate = specialCase.returnDate;
                        customer.salesAmount = customer.totalIncome - customer.depositAmount;
                        customer.salesType = 'trade';
                        return;
                    }
                    
                    // 강민국: 강효순 명의 보증금 환급완료
                    if (specialCase.type === 'linked_to_kanghyosoon') {
                        customer.depositAmount = specialCase.depositAmount;
                        customer.depositDate = incomeTransactions[0].date;
                        customer.depositStatus = 'returned';
                        customer.returnDate = specialCase.returnDate;
                        customer.salesAmount = customer.totalIncome - customer.depositAmount;
                        customer.salesType = 'trade';
                        return;
                    }
                    
                    // 신수연: 부분환급 케이스 (1500만원 보증금 → 1000만원 환급 → 잔액 500만원)
                    if (specialCase.type === 'partial_refund') {
                        customer.depositAmount = specialCase.remainingDeposit; // 잔액 500만원
                        customer.depositDate = incomeTransactions[0].date; // 첫 보증금 날짜
                        customer.depositStatus = 'unreturned'; // 아직 500만원 잔액 있음
                        customer.returnDate = null; // 부분환급이므로 완전환급일 없음
                        customer.salesAmount = customer.totalIncome - specialCase.totalDeposit; // 전체 매출에서 총 보증금 제외
                        customer.salesType = 'trade';
                        customer.partialRefundInfo = {
                            totalDeposit: specialCase.totalDeposit,
                            partialRefund: specialCase.partialRefund,
                            refundDate: specialCase.refundDate,
                            remainingDeposit: specialCase.remainingDeposit
                        };
                        return;
                    }
                    
                    // 이유진: 복잡한 보증금 케이스 (보증금 50만원, 월이용료 차감 104,000원, 환불 1,009,475원)
                    if (specialCase.type === 'complex_deposit_case') {
                        customer.depositAmount = specialCase.depositAmount; // 50만원 보증금
                        customer.depositDate = incomeTransactions[0].date; // 첫 보증금 날짜
                        customer.depositStatus = 'unreturned'; // 월이용료 차감 후 잔액 있음
                        customer.returnDate = null;
                        
                        // 실제 매출 = 총 매출 - 환불 금액
                        customer.salesAmount = Math.max(0, customer.totalIncome - specialCase.actualRefund);
                        customer.salesType = 'trade';
                        
                        // 복잡한 케이스 정보 저장
                        customer.complexCaseInfo = {
                            originalDeposit: specialCase.depositAmount,
                            monthlyFeeDeduction: specialCase.monthlyFeeDeduction,
                            actualRefund: specialCase.actualRefund,
                            remainingDeposit: Math.max(0, specialCase.depositAmount - specialCase.monthlyFeeDeduction),
                            actualSales: customer.salesAmount
                        };
                        return;
                    }
                    
                    // 이유진: 보증금 50만원 미환급
                    if (specialCase.type === 'deposit_500000_unreturned') {
                        customer.depositAmount = specialCase.depositAmount;
                        customer.depositDate = null; // 이전 기간 보증금
                        customer.depositStatus = 'unreturned';
                        customer.salesAmount = customer.totalIncome; // 현재 기간 거래는 모두 매출
                        customer.salesType = 'trade';
                        return;
                    }
                    
                    // 김규, 전환승, 정익만: 지정된 보증금 + 나머지 매출
                    if (specialCase.type === 'deposit_500000' || specialCase.type === 'deposit_100000' || specialCase.type === 'deposit_300000') {
                        customer.depositAmount = specialCase.depositAmount;
                        customer.depositDate = incomeTransactions[0].date;
                        customer.depositStatus = 'unreturned';
                        customer.salesAmount = Math.max(0, customer.totalIncome - customer.depositAmount);
                        customer.salesType = 'trade';
                        
                        // 정익만의 경우 매출이 충분히 있다고 가정 (hasSales 플래그)
                        if (specialCase.hasSales && customer.salesAmount === 0) {
                            customer.salesAmount = Math.max(100000, customer.totalIncome * 0.1); // 최소 매출 보장
                        }
                        
                        return;
                    }
                    
                    // 김진호: 보증금 환급완료 - 실제 매출은 94,071원
                    if (specialCase.type === 'deposit_refund_complete') {
                        customer.depositAmount = 0; // 환급완료이므로 보증금 0
                        customer.depositDate = incomeTransactions[0].date;
                        customer.depositStatus = 'returned';
                        customer.returnDate = specialCase.returnDate;
                        customer.salesAmount = specialCase.salesAmount; // 실제 매출 직접 지정
                        customer.salesType = 'trade';
                        customer.originalDepositAmount = specialCase.depositAmount; // 원래 보증금 기록용
                        return;
                    }
                    
                    // 최재연: 보증금 50만원 환급완료
                    if (specialCase.type === 'deposit_500000_returned') {
                        customer.depositAmount = specialCase.depositAmount;
                        customer.depositDate = incomeTransactions[0].date;
                        customer.depositStatus = 'returned';
                        customer.returnDate = specialCase.returnDate;
                        customer.salesAmount = customer.totalIncome - customer.depositAmount;
                        customer.salesType = 'trade';
                        return;
                    }
                    
                    if (specialCase.type === 'deposit_500') {
                        // 조태련: 처음 3번 입금 (총 500만원)이 보증금, 나머지는 매출
                        let depositSum = 0;
                        let depositTransactions = 0;
                        
                        for (let i = 0; i < incomeTransactions.length && depositSum < 5000000; i++) {
                            depositSum += incomeTransactions[i].inAmount;
                            depositTransactions++;
                            if (depositSum >= 5000000) break;
                        }
                        
                        customer.depositAmount = Math.min(depositSum, 5000000); // 최대 500만원
                        customer.depositDate = incomeTransactions[0].date;
                        customer.depositStatus = 'unreturned';
                        customer.salesAmount = customer.totalIncome - customer.depositAmount;
                        customer.salesType = 'trade';
                        return;
                    } else if (specialCase.type === 'boutique_forced') {
                        // 번장 후루추, 장유은, 김영주 등: 강제 부티크 매출
                        customer.depositAmount = 0; // 보증금 없음
                        customer.salesAmount = customer.totalIncome; // 전부 매출
                        customer.salesType = 'boutique'; // 강제 부티크
                        return;
                    } else if (specialCase.type === 'pre_deposit') {
                        // 디엔디: 전부 매출 (예치금 형태, 보증금 절대 없음)
                        customer.depositAmount = 0; // 보증금 절대 없음
                        customer.depositStatus = 'none'; // 보증금 상태 없음
                        customer.depositDate = null; // 보증금 날짜 없음
                        customer.returnDate = null; // 환급 날짜 없음
                        customer.salesAmount = customer.totalIncome; // 전부 매출
                        customer.salesType = 'trade'; // 트레이드 매출
                        return;
                    } else if (specialCase.type === 'full_refund') {
                        // 테이밍랩: 전액 환불
                        customer.depositAmount = customer.totalIncome; // 입금액 전체가 보증금
                        customer.depositDate = incomeTransactions[0].date;
                        customer.depositStatus = 'returned'; // 환급완료로 처리
                        customer.returnDate = '2024-05-01';
                        customer.salesAmount = 0; // 매출 0
                        customer.salesType = 'trade';
                        return;
                    } else if (specialCase.type === 'deposit_1000000') {
                        // 강효순: 강민국 보증금(엄마명의)
                        customer.depositAmount = 1000000;
                        customer.depositDate = incomeTransactions[0].date;
                        customer.depositStatus = 'unreturned';
                        customer.salesAmount = customer.totalIncome - customer.depositAmount;
                        customer.salesType = 'trade'; // 보증금이 있으므로 트레이드
                        return;
                    } else if (specialCase.type === 'deposit_management') {
                        customer.salesAmount = customer.totalIncome - customer.totalOutcome;
                        customer.salesType = 'trade'; // 예치금 관리이므로 트레이드
                        return;
                    }
                }
                
                const firstTransaction = incomeTransactions[0];
                
                // 보증금 판별 로직 (100만원 이상 첫 입금)
                if (firstTransaction.inAmount >= 1000000) {
                    customer.depositAmount = firstTransaction.inAmount;
                    customer.depositDate = firstTransaction.date;
                    customer.depositStatus = 'unreturned';
                    
                    customer.salesAmount = customer.totalIncome - customer.depositAmount;
                    
                    const outcomeTransactions = customer.transactions.filter(t => t.type === '출금');
                    const refundTransaction = outcomeTransactions.find(t => 
                        Math.abs(t.outAmount - customer.depositAmount) < 50000
                    );
                    
                    if (refundTransaction) {
                        customer.depositStatus = 'returned';
                        customer.returnDate = refundTransaction.date;
                    }
                } else {
                    customer.salesAmount = customer.totalIncome;
                }
                
                // 매출 타입 분류 (트레이드 vs 부티크)
                customer.salesType = classifyCustomerSalesType(customer);
                
                // 5월 기준 환급완료 정보 적용
                const refundInfo = knownRefunds[customer.name];
                if (refundInfo && customer.name !== '테이밍랩') { // 테이밍랩은 specialCase에서 처리
                    if (customer.depositAmount === 0 && refundInfo.amount > 0) {
                        // 보증금이 자동 감지되지 않은 경우 수동 설정
                        customer.depositAmount = refundInfo.amount;
                        customer.depositDate = customer.firstTransactionDate ? customer.firstTransactionDate.toISOString().split('T')[0] : refundInfo.date;
                    }
                    customer.depositStatus = 'returned';
                    customer.returnDate = refundInfo.date;
                    customer.salesAmount = Math.max(0, customer.totalIncome - customer.depositAmount);
                    customer.salesType = 'trade';
                }
            });
            
            // ★★★ 중요: 자동분석 완료 후 직원분류 적용 ★★★
            console.log('=== 직원분류 적용 시작 ===');
            Object.values(allCustomers).forEach(customer => {
                if (customer.excluded) return;
                
                // 이 고객의 거래 중 직원분류가 있는지 확인
                const hasManualClassification = customer.transactions.some(t => {
                    const tId = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                    return staffClassifications[tId];
                });
                
                if (hasManualClassification) {
                    console.log(`${customer.name}에 직원분류 발견 - 재계산 진행`);
                    recalculateCustomerData(customer);
                }
            });
            console.log('=== 직원분류 적용 완료 ===');
            
            // =================================================================
            // ★★★★★ 김진호 데이터 강제 수정 코드 (v2) 시작 ★★★★★
            // =================================================================
            if (allCustomers['김진호']) {
                const customer = allCustomers['김진호'];
                console.log('=== 김진호 강제 수정 시작 ===');

                // 1. 대표님이 확인한 최종 값으로 강제 설정
                const realSales = 576168; // 이것이 진짜 매출액
                const unpaidDebt = 94071;   // 환급 시 차감한 미결제금

                // 2. 이 고객의 총 입금액을 '매출 + 미결제금'의 합으로 재정의
                const totalValue = realSales + unpaidDebt; // 670,239

                // 3. 고객 객체의 모든 값을 이 기준에 맞춰 강제로 덮어쓰기
                customer.salesAmount = realSales;             // 최종 매출액 표시
                customer.depositStatus = 'returned';          // 상태: 환급 완료
                customer.returnDate = '2025-07-06';           // 환급 처리일
                customer.depositAmount = 0;                   // 현재 남은 보증금: 0원
                customer.originalDepositAmount = totalValue;  // 최초 보증금 총액
                customer.totalIncome = totalValue;            // 총 입금액 강제 설정
                customer.totalOutcome = totalValue;           // 총 출금액(매출+상계) 강제 설정
                customer.balance = 0;                         // 최종 잔액: 0원
                customer.salesType = 'trade';
                customer.note = '매출 576,168원 확정. 미결제 94,071원 상계 후 환급 완료 처리.';
                
                console.log('김진호 강제 수정 완료:', customer);
            }
            // =================================================================
            // ★★★★★ 김진호 데이터 강제 수정 코드 종료 ★★★★★
            // =================================================================
        }
    
            function safeUpdate(fn, name) {
            try { fn(); }
            catch (e) { console.error(`탭 업데이트 오류: ${name}`, e); }
        }

        function updateAllTabs() {
            // =================================================================
        // =================================================================
        // ★★★★★ 김진호 데이터 최종 강제 수정 코드 v4 (완결판) ★★★★★
        // =================================================================
        if (allCustomers['김진호']) {
            console.log('김진호 데이터 v4 최종 덮어쓰기 로직 실행!');
            const customer = allCustomers['김진호'];

            const realSales = 576168;
            const fee = 94071;
            const originalDeposit = 5000000;
            const refundSent = 4905929;

            // 1. '멍청한 계산기'를 속이기 위해 총 입출금액 자체를 재정의
            customer.totalIncome = originalDeposit + realSales; // 5,576,168
            customer.totalOutcome = refundSent + realSales + fee; // 5,576,168 (환급액+매출+수수료)
            customer.balance = 0; // 최종 잔액 0으로 강제

            // 2. '똑똑한 계산기'를 위한 상세 정보 재정의
            customer.salesAmount = realSales;
            customer.depositAmount = 0; // 현재 남은 보증금 0
            customer.originalDepositAmount = originalDeposit; // 원래 보증금 500만
            customer.depositStatus = 'returned';
            customer.returnDate = '2025-08-31';
            customer.note = '보증금 500만원 정산 완료 (최종 수정)';
        }
        // =================================================================
        // ★★★★★ 김진호 데이터 최종 강제 수정 코드 종료 ★★★★★
        // =================================================================
            safeUpdate(updateHeaderStats, 'header');
            safeUpdate(updateCEODashboard, 'ceoDashboard');
            safeUpdate(updateDepositsTab, 'deposits');
            safeUpdate(updateTradeSalesTab, 'tradeSales');
            safeUpdate(updateBoutiqueSalesTab, 'boutiqueSales');
            safeUpdate(updateMonthlyTab, 'monthly');
            safeUpdate(updateTransactionsTab, 'transactions');
        }
    
        function updateHeaderStats() {
            const incomeTransactions = allTransactions.filter(t => t.type === '입금' && !t.excluded);
            const totalIncome = incomeTransactions.reduce((sum, t) => sum + t.inAmount, 0);
            const totalCustomers = Object.keys(allCustomers).filter(name => !allCustomers[name].excluded).length;
            
            const totalSales = Object.values(allCustomers)
                .filter(c => !c.excluded)
                .reduce((sum, c) => sum + c.salesAmount, 0);
            
            document.getElementById('totalTransactions').textContent = allTransactions.length.toLocaleString() + '건';
            document.getElementById('totalIncome').textContent = '₩' + totalIncome.toLocaleString();
            document.getElementById('totalCustomers').textContent = totalCustomers + '명';
            document.getElementById('finalSalesAmount').textContent = '₩' + totalSales.toLocaleString();
        }
    
        function updateCEODashboard() {
            // 직원이 제외로 분류한 고객들을 필터링
            const staffExcludedCustomers = Object.keys(staffClassifications)
                .filter(transactionId => staffClassifications[transactionId] === 'exclude')
                .map(transactionId => {
                    const parts = transactionId.split('_');
                    return parts.length >= 2 ? parts[1] : null;
                })
                .filter(name => name);
            
            const nonExcludedCustomers = Object.values(allCustomers).filter(c => {
                // 기본 제외 고객
                if (c.excluded) return false;
                
                // 직원이 제외로 분류한 고객도 제외
                if (staffExcludedCustomers.includes(c.name)) return false;
                
                return true;
            });
            
            const totalDeposits = nonExcludedCustomers.reduce((sum, c) => sum + c.depositAmount, 0);
            const totalSales = nonExcludedCustomers.reduce((sum, c) => sum + c.salesAmount, 0);
            
            // 진정한 이탈 위험 고객 (보증금 있으나 매출 없는 고객, BUT 환급완료는 제외!)
            const riskCustomers = nonExcludedCustomers.filter(c => {
                // 보증금이 있어야 함
                if (c.depositAmount <= 0) return false;
                
                // 환급완료된 고객은 위험하지 않음 (정상적인 거래 완료)
                if (c.depositStatus === 'returned') return false;
                
                // 강효순은 강민국과 같은 사람이므로 제외 (중복 방지)
                if (specialCases[c.name] && specialCases[c.name].excludeFromDepositManagement) return false;
                
                // 정익만은 실제로 매출이 있으므로 위험고객에서 제외
                if (specialCases[c.name] && specialCases[c.name].hasSales) return false;
                
                // 핵심 로직: 보증금은 있지만 매출이 전혀 없는 경우만 위험
                // (매출이 있다면 보증금을 잘 활용하고 있는 것이므로 건전한 고객)
                if (c.salesAmount > 0) return false;
                
                // 추가 조건: 보증금 입금 후 90일 이상 경과했는데도 매출이 없는 경우
                if (c.depositDate) {
                    const daysSinceDeposit = Math.floor((new Date() - new Date(c.depositDate)) / (1000 * 60 * 60 * 24));
                    if (daysSinceDeposit < 90) return false; // 90일 미만이면 아직 위험하지 않음
                }
                
                return true;
            });
            
            // 보증금 효율성 (매출 / 보증금 비율)
            const efficiency = totalDeposits > 0 ? ((totalSales / totalDeposits) * 100).toFixed(1) : 0;
            
            // 트레이드 vs 부티크 매출
            const tradeCustomers = nonExcludedCustomers.filter(c => c.salesType === 'trade');
            const boutiqueCustomers = nonExcludedCustomers.filter(c => c.salesType === 'boutique');
            const tradeSales = tradeCustomers.reduce((sum, c) => sum + c.salesAmount, 0);
            const boutiqueSales = boutiqueCustomers.reduce((sum, c) => sum + c.salesAmount, 0);
            
            document.getElementById('ceoDashboardTotalDeposits').textContent = '₩' + totalDeposits.toLocaleString();
            document.getElementById('ceoDashboardTotalSales').textContent = '₩' + totalSales.toLocaleString();
            document.getElementById('ceoDashboardRiskCustomers').textContent = riskCustomers.length + '명';
            document.getElementById('ceoDashboardEfficiency').textContent = efficiency + '%';
            
            document.getElementById('ceoDashboardDepositDetail').textContent = `미환급 ${nonExcludedCustomers.filter(c => c.depositStatus === 'unreturned').length}명 + 환급완료 ${nonExcludedCustomers.filter(c => c.depositStatus === 'returned').length}명`;
            document.getElementById('ceoDashboardSalesDetail').textContent = `트레이드 ₩${tradeSales.toLocaleString()} + 부티크 ₩${boutiqueSales.toLocaleString()}`;
            document.getElementById('ceoDashboardRiskDetail').textContent = riskCustomers.length > 0 ? `총 보증금 ₩${riskCustomers.reduce((sum, c) => sum + c.depositAmount, 0).toLocaleString()}` : '위험 고객 없음';
            document.getElementById('ceoDashboardEfficiencyDetail').textContent = totalDeposits > 0 ? `보증금 ₩${totalDeposits.toLocaleString()} 대비 매출 효율성` : '보증금 없음';
            
            // 월별 성장 차트 (간단한 텍스트 형태)
            updateMonthlyGrowthChart();
            
            // 고객 성장 패턴 (간단한 텍스트 형태)
            updateCustomerGrowthChart();
            
            // 이탈 위험 고객 목록
            updateRiskCustomersList(riskCustomers);
            
            // 업로드 히스토리
            updateUploadHistory();
        }
    
        function updateMonthlyGrowthChart() {
            const salesTransactions = allTransactions.filter(t => {
                if (t.type !== '입금' || t.excluded) return false;
                const customer = allCustomers[t.customer];
                if (!customer || customer.salesAmount <= 0) return false;
                
                // 보증금 거래 완전 제외
                const isDepositTransaction = customer.depositAmount > 0 && t.inAmount === customer.depositAmount && t.date === customer.depositDate;
                if (isDepositTransaction) return false;
                
                // 특별 케이스 보증금도 제외
                if (specialCases[customer.name]) {
                    const specialCase = specialCases[customer.name];
                    if (specialCase.type === 'deposit_2000000' && t.inAmount >= 1000000) return false;
                    if (specialCase.type === 'linked_to_kanghyosoon' && t.inAmount >= 500000) return false;
                    if (specialCase.type === 'deposit_500000' && t.inAmount === 500000) return false;
                    if (specialCase.type === 'deposit_100000' && t.inAmount === 100000) return false;
                    if (specialCase.type === 'deposit_300000' && t.inAmount === 300000) return false;
                    if (specialCase.type === 'deposit_500000_returned' && t.inAmount === 500000) return false;
                    if (specialCase.type === 'deposit_refund_complete' && t.inAmount === specialCase.depositAmount) return false;
                    if (specialCase.type === 'deposit_500' && t.inAmount >= 1000000) return false;
                    if (specialCase.type === 'deposit_1000000' && t.inAmount >= 1000000) return false;
                    if (specialCase.type === 'deposit_1000000_for_kangminguk' && t.inAmount >= 1000000) return false;
                    if (specialCase.type === 'full_refund') return false;
                }
                
                return true;
            });
            
            const monthlyData = {};
            salesTransactions.forEach(t => {
                const yearMonth = `${t.parsedDate.getFullYear()}-${String(t.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[yearMonth]) {
                    monthlyData[yearMonth] = 0;
                }
                monthlyData[yearMonth] += t.inAmount;
            });
            
            const recentMonths = Object.keys(monthlyData).sort().slice(-3);
            let chartHTML = '';
            
            recentMonths.forEach((month, index) => {
                const amount = monthlyData[month];
                const prevMonth = recentMonths[index - 1];
                const growth = prevMonth ? ((amount - monthlyData[prevMonth]) / monthlyData[prevMonth] * 100).toFixed(1) : 0;
                
                chartHTML += `
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span>${month}</span>
                        <span>₩${amount.toLocaleString()}</span>
                        <span style="color: ${growth >= 0 ? '#059669' : '#dc2626'}">${growth >= 0 ? '▲' : '▼'}${growth}%</span>
                    </div>
                `;
            });
            
            document.getElementById('monthlyGrowthChart').innerHTML = chartHTML || '<p>매출 데이터 없음</p>';
        }
        
        function updateCustomerGrowthChart() {
            const monthlyNewCustomers = {};
            
            Object.values(allCustomers).forEach(customer => {
                if (customer.excluded || !customer.firstTransactionDate || customer.salesAmount <= 0) return;
                
                const yearMonth = `${customer.firstTransactionDate.getFullYear()}-${String(customer.firstTransactionDate.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyNewCustomers[yearMonth]) {
                    monthlyNewCustomers[yearMonth] = [];
                }
                monthlyNewCustomers[yearMonth].push(customer.name);
            });
            
            const recentMonths = Object.keys(monthlyNewCustomers).sort().slice(-3);
            let chartHTML = '';
            
            recentMonths.forEach(month => {
                const customers = monthlyNewCustomers[month];
                const count = customers.length;
                const customerList = customers.slice(0, 5).join(', ') + (customers.length > 5 ? ` 외 ${customers.length - 5}명` : '');
                
                chartHTML += `
                    <div style="margin-bottom: 15px; padding: 8px; background: #f8fafc; border-radius: 5px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span><strong>${month}</strong></span>
                            <span><strong>${count}명 신규</strong></span>
                        </div>
                        <div style="font-size: 0.8em; color: #6b7280;">
                            ${customerList}
                        </div>
                    </div>
                `;
            });
            
            document.getElementById('customerGrowthChart').innerHTML = chartHTML || '<p>신규 고객 없음</p>';
        }
        
        function updateRiskCustomersList(riskCustomers) {
            let listHTML = '';
            
            if (riskCustomers.length === 0) {
                listHTML = '<p style="color: #059669; text-align: center; padding: 20px;">🎉 현재 이탈 위험 고객이 없습니다!</p>';
            } else {
                listHTML = `
                    <table style="width: 100%; font-size: 0.9em;">
                        <thead>
                            <tr><th>고객명</th><th>보증금</th><th>보증금 날짜</th><th>경과일수</th><th>액션</th></tr>
                        </thead>
                        <tbody>
                `;
                
                riskCustomers.forEach(customer => {
                    const daysSinceDeposit = customer.depositDate ? 
                        Math.floor((new Date() - new Date(customer.depositDate)) / (1000 * 60 * 60 * 24)) : 0;
                    
                    listHTML += `
                        <tr>
                            <td><strong>${customer.name}</strong></td>
                            <td class="amount-negative">₩${customer.depositAmount.toLocaleString()}</td>
                            <td>${customer.depositDate || '-'}</td>
                            <td>${daysSinceDeposit}일</td>
                            <td><button class="btn" style="padding: 4px 8px; font-size: 0.8em;" onclick="showTab('deposits')">관리</button></td>
                        </tr>
                    `;
                });
                
                listHTML += '</tbody></table>';
            }
            
            document.getElementById('riskCustomersList').innerHTML = listHTML;
        }
    
        function updateTradeSalesTab() {
            const tbody = document.querySelector('#tradeTable tbody');
            tbody.innerHTML = '';
            
            // 거래 단위 최신순 테이블로 변경 (입금 중 보증금/월이용료/제외 제외, 직원분류 'trade' 포함)
            const tradeTransactions = allTransactions
                .filter(t => {
                    if (t.type !== '입금' || t.excluded) return false;
                    const customer = allCustomers[t.customer];
                    if (!customer) return false;
                    // 보증금 거래 제외
                    if (isTransactionDeposit(customer, t)) return false;
                    // 직원분류 식별
                    const tId = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                    const staffClass = staffClassifications[tId];
                    // 월이용료 제외
                    if (staffClass === 'monthlyFee') return false;
                    // 트레이드 판정: 고객이 트레이드이거나, 보증금 고객이거나, 직원분류가 trade
                    return customer.salesType === 'trade' || customer.depositAmount > 0 || staffClass === 'trade';
                })
                .sort((a, b) => b.parsedDate - a.parsedDate);
            
            const totalTradeSales = tradeTransactions.reduce((sum, t) => sum + (t.inAmount || 0), 0);
            const avgTradeSales = tradeTransactions.length > 0 ? Math.round(totalTradeSales / tradeTransactions.length) : 0;
            const highValueCustomers = Array.from(new Set(tradeTransactions.filter(t => (t.inAmount || 0) >= 5000000).map(t => t.customer)));
            const tradeWithDeposits = Array.from(new Set(tradeTransactions.filter(t => (allCustomers[t.customer]?.depositAmount || 0) > 0).map(t => t.customer)));
            const uniqueTradeCustomers = Array.from(new Set(tradeTransactions.map(t => t.customer)));
            
            // 요약 정보 표시
            const summaryGrid = document.getElementById('tradeSummaryGrid');
            summaryGrid.innerHTML = `
                <div class="summary-card">
                    <div class="summary-title">🏪 총 트레이드 매출</div>
                    <div class="summary-value">₩${totalTradeSales.toLocaleString()}</div>
                    <div class="summary-detail">${uniqueTradeCustomers.length}명 트레이드 고객</div>
                </div>
                <div class="summary-card">
                    <div class="summary-title">💰 평균 매출</div>
                    <div class="summary-value">₩${avgTradeSales.toLocaleString()}</div>
                    <div class="summary-detail">고객당 평균 트레이드 매출</div>
                </div>
                <div class="summary-card">
                    <div class="summary-title">⭐ 고매출 고객</div>
                    <div class="summary-value">${highValueCustomers.length}명</div>
                    <div class="summary-detail">500만원 이상 매출 고객</div>
                </div>
                <div class="summary-card">
                    <div class="summary-title">🏦 보증금 연계</div>
                    <div class="summary-value">${tradeWithDeposits.length}명</div>
                    <div class="summary-detail">보증금이 있는 트레이드 고객</div>
                </div>
            `;
            
            // 고객별 누적 매출 계산용
            const customerRunningTotal = {};
            tradeTransactions.forEach(t => {
                const customer = allCustomers[t.customer];
                const row = tbody.insertRow();
                row.className = 'customer-row';
                const statusBadge = (customer.depositAmount || 0) > 0 ? (customer.depositStatus === 'returned' ? '<span class="status-badge status-returned">환급완료</span>' : '<span class="status-badge status-unreturned">미환급</span>') : '<span class="status-badge status-sales">매출만</span>';
                customerRunningTotal[t.customer] = (customerRunningTotal[t.customer] || 0) + (t.inAmount || 0);
                row.innerHTML = `
                    <td>${t.date}</td>
                    <td><strong>${t.customer}</strong></td>
                    <td class="amount-large">₩${(t.inAmount || 0).toLocaleString()}</td>
                    <td>트레이드</td>
                    <td class="amount-positive">₩${customerRunningTotal[t.customer].toLocaleString()}</td>
                    <td>${statusBadge}</td>
                    <td><button class="btn" style="padding: 5px 10px; font-size: 0.8em;" onclick="event.stopPropagation(); showTradeDetails('${t.customer.replace(/'/g, "\\'")}')">상세보기</button></td>
                `;
                row.setAttribute('data-customer', t.customer);
            });
        }

        function updateBoutiqueSalesTab() {
            const tbody = document.querySelector('#boutiqueTable tbody');
            tbody.innerHTML = '';
            
            const boutiqueCustomers = Object.values(allCustomers)
                .filter(c => !c.excluded && c.salesAmount > 0 && c.salesType === 'boutique')
                .sort((a, b) => b.salesAmount - a.salesAmount);
            
            const totalBoutiqueSales = boutiqueCustomers.reduce((sum, c) => sum + c.salesAmount, 0);
            const avgBoutiqueSales = boutiqueCustomers.length > 0 ? Math.round(totalBoutiqueSales / boutiqueCustomers.length) : 0;
            const highValueCustomers = boutiqueCustomers.filter(c => c.salesAmount >= 2000000);
            const oneTimeCustomers = boutiqueCustomers.filter(c => c.transactions.filter(t => t.type === '입금').length === 1);
            
            // 요약 정보 표시
            const summaryGrid = document.getElementById('boutiqueSummaryGrid');
            summaryGrid.innerHTML = `
                <div class="summary-card">
                    <div class="summary-title">🛍️ 총 부티크 매출</div>
                    <div class="summary-value">₩${totalBoutiqueSales.toLocaleString()}</div>
                    <div class="summary-detail">${boutiqueCustomers.length}명 부티크 고객</div>
                </div>
                <div class="summary-card">
                    <div class="summary-title">💰 평균 매출</div>
                    <div class="summary-value">₩${avgBoutiqueSales.toLocaleString()}</div>
                    <div class="summary-detail">고객당 평균 부티크 매출</div>
                </div>
                <div class="summary-card">
                    <div class="summary-title">⭐ 고매출 고객</div>
                    <div class="summary-value">${highValueCustomers.length}명</div>
                    <div class="summary-detail">200만원 이상 매출 고객</div>
                </div>
                <div class="summary-card">
                    <div class="summary-title">🔄 단발 고객</div>
                    <div class="summary-value">${oneTimeCustomers.length}명</div>
                    <div class="summary-detail">1회성 구매 고객</div>
                </div>
            `;
            
            boutiqueCustomers.forEach(customer => {
                const row = tbody.insertRow();
                row.className = 'customer-row';
                
                const period = customer.firstTransactionDate && customer.lastTransactionDate ? 
                    (customer.firstTransactionDate.getTime() === customer.lastTransactionDate.getTime() ? 
                        customer.firstTransactionDate.toLocaleDateString('ko-KR', {year: '2-digit', month: 'numeric', day: 'numeric'}) :
                        `${customer.firstTransactionDate.toLocaleDateString('ko-KR', {year: '2-digit', month: 'numeric', day: 'numeric'})} ~ ${customer.lastTransactionDate.toLocaleDateString('ko-KR', {year: '2-digit', month: 'numeric', day: 'numeric'})}`) : 
                    '-';
                
                const incomeCount = customer.transactions.filter(t => t.type === '입금').length;
                
                // 월평균 매출 계산
                let monthlyAverage = 0;
                if (customer.firstTransactionDate && customer.lastTransactionDate) {
                    const monthsDiff = Math.max(1, Math.ceil((customer.lastTransactionDate - customer.firstTransactionDate) / (1000 * 60 * 60 * 24 * 30)));
                    monthlyAverage = Math.round(customer.salesAmount / monthsDiff);
                }
                
                row.innerHTML = `
                    <td><strong>${customer.name}</strong></td>
                    <td class="amount-large">₩${customer.salesAmount.toLocaleString()}</td>
                    <td>${incomeCount}건</td>
                    <td style="font-size: 0.9em;">${period}</td>
                    <td class="amount-positive">₩${monthlyAverage.toLocaleString()}</td>
                    <td>${customer.firstTransactionDate ? customer.firstTransactionDate.toLocaleDateString('ko-KR') : '-'}</td>
                    <td><button class="btn" style="padding: 5px 10px; font-size: 0.8em;" onclick="event.stopPropagation(); showBoutiqueDetails('${customer.name.replace(/'/g, "\\'")}')">상세보기</button></td>
                `;
                
                row.setAttribute('data-customer', customer.name);
            });
        }
        
        function showTradeDetails(customerName) {
            const customer = allCustomers[customerName];
            if (!customer) return;
            
            // 새로운 상세 고객 프로필 윈도우 생성
            const detailWindow = document.createElement('div');
            detailWindow.id = 'customerDetailWindow';
            detailWindow.style.cssText = `
                position: fixed; top: 5%; left: 10%; width: 80%; height: 85%; 
                background: white; border-radius: 15px; box-shadow: 0 10px 50px rgba(0,0,0,0.3);
                z-index: 1000; overflow-y: auto; padding: 0;
            `;
            
            // 시간순 거래 내역 생성
            const sortedTransactions = customer.transactions
                .map(t => ({
                    ...t,
                    classification: getTransactionClassification(customer, t)
                }))
                .sort((a, b) => b.parsedDate - a.parsedDate);
            
            // 월별 매출 트렌드 계산
            const monthlyTrend = calculateMonthlyTrend(customer);
            
            detailWindow.innerHTML = `
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; border-radius: 15px 15px 0 0;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <h2>${customerName} 고객 완전 프로필</h2>
                        <button onclick="closeCustomerDetail()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px 15px; border-radius: 5px; cursor: pointer;">✕ 닫기</button>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-top: 15px;">
                        <div><strong>총 보증금 입금:</strong><br>₩${customer.transactions.filter(t => getTransactionClassification(customer, t) === 'deposit').reduce((sum, t) => sum + t.inAmount, 0).toLocaleString()}</div>
                        <div><strong>현재 보증금 잔액:</strong><br>₩${customer.depositAmount.toLocaleString()}</div>
                        <div><strong>총 매출:</strong><br>₩${customer.salesAmount.toLocaleString()}</div>
                        <div><strong>거래 활동도:</strong><br>${customer.transactions.length}건 (${Math.round((new Date() - customer.firstTransactionDate) / (1000*60*60*24))}일간)</div>
                    </div>
                </div>
                
                <div style="padding: 25px;">
                    <!-- 월별 매출 트렌드 -->
                    <div style="background: #f8fafc; padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                        <h4 style="margin-bottom: 15px;">📈 월별 매출 트렌드</h4>
                        <div style="display: flex; gap: 15px; align-items: end; height: 100px;">
                            ${monthlyTrend.map(month => `
                                <div style="flex: 1; text-align: center;">
                                    <div style="background: #2563eb; width: 100%; height: ${Math.max(5, (month.amount / Math.max(...monthlyTrend.map(m => m.amount))) * 80)}px; margin-bottom: 5px; border-radius: 3px;"></div>
                                    <div style="font-size: 0.8em;">${month.month}</div>
                                    <div style="font-size: 0.7em; color: #059669;">₩${month.amount.toLocaleString()}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    
                    <!-- 거래 내역 타임라인 -->
                    <h4 style="margin-bottom: 15px;">🕒 전체 거래 타임라인 (최신순)</h4>
                    <div style="max-height: 400px; overflow-y: auto;">
                        ${sortedTransactions.map(t => {
                            const isIncome = t.type === '입금';
                            const bgColor = t.classification === 'deposit' ? '#fef3c7' : 
                                           t.classification === 'sales' ? '#f0fdf4' : 
                                           t.classification === 'refund' ? '#fef2f2' : '#f9fafb';
                            const icon = t.classification === 'deposit' ? '🏦' :
                                        t.classification === 'sales' ? '💰' :
                                        t.classification === 'refund' ? '↩️' : '📝';
                            
                            return `
                                <div style="background: ${bgColor}; padding: 15px; margin-bottom: 8px; border-radius: 8px; border-left: 4px solid ${isIncome ? '#059669' : '#dc2626'};">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="font-size: 1.2em;">${icon}</span>
                                            <div>
                                                <div style="font-weight: bold;">${t.date}</div>
                                                <div style="font-size: 0.9em; color: #6b7280;">${t.classification === 'deposit' ? '보증금 입금' : t.classification === 'sales' ? '매출 (상품구매)' : t.classification === 'refund' ? '보증금 환급' : '일반 ' + t.type}</div>
                                            </div>
                                        </div>
                                        <div style="text-align: right;">
                                            <div style="font-size: 1.2em; font-weight: bold; color: ${isIncome ? '#059669' : '#dc2626'};">
                                                ${isIncome ? '+' : '-'}₩${(t.inAmount || t.outAmount).toLocaleString()}
                                            </div>
                                            <div style="font-size: 0.8em; color: #6b7280;">${t.type}</div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
            
            // 기존 상세창이 있으면 제거
            const existing = document.getElementById('customerDetailWindow');
            if (existing) existing.remove();
            
            document.body.appendChild(detailWindow);
        }
        
        function getTransactionClassification(customer, transaction) {
            if (transaction.type === '출금') {
                if (customer.returnDate && transaction.date === customer.returnDate) {
                    return 'refund';
                }
                // 직원 분류 확인해 월이용료 처리
                const tId = `${transaction.date}_${transaction.customer}_${transaction.inAmount || transaction.outAmount}`;
                if (staffClassifications[tId] === 'monthlyFee') return 'monthlyFee';
                if (staffClassifications[tId] === 'actualRefund') return 'actualRefund';
                return 'outgoing';
            }
            
            // 보증금 판별
            if (isTransactionDeposit(customer, transaction)) {
                return 'deposit';
            }
            
            // 직원 분류 확인 (월이용료가 입금으로 표시된 경우 등)
            const tId2 = `${transaction.date}_${transaction.customer}_${transaction.inAmount || transaction.outAmount}`;
            if (staffClassifications[tId2] === 'monthlyFee') return 'monthlyFee';
            if (staffClassifications[tId2] === 'actualRefund') return 'actualRefund';

            // 나머지는 매출
            return 'sales';
        }
        
        function calculateMonthlyTrend(customer) {
            const monthlyData = {};
            
            customer.transactions
                .filter(t => t.type === '입금' && getTransactionClassification(customer, t) === 'sales')
                .forEach(t => {
                    const month = `${t.parsedDate.getFullYear()}-${String(t.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                    if (!monthlyData[month]) monthlyData[month] = 0;
                    monthlyData[month] += t.inAmount;
                });
            
            return Object.keys(monthlyData)
                .sort()
                .slice(-6) // 최근 6개월
                .map(month => ({
                    month: month.substring(5), // MM만 표시
                    amount: monthlyData[month]
                }));
        }
        
        function closeCustomerDetail() {
            const detailWindow = document.getElementById('customerDetailWindow');
            if (detailWindow) detailWindow.remove();
        }
        
        // 고객 병합 관련 함수들
        function showCustomerMergeModal() {
            const existingModal = document.getElementById('customerMergeModal');
            if (existingModal) existingModal.remove();
            
            const customerNames = Object.keys(allCustomers).filter(name => !allCustomers[name].excluded).sort();
            
            const modal = document.createElement('div');
            modal.id = 'customerMergeModal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.5); z-index: 2000; 
                display: flex; align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 15px; width: 600px; max-height: 80vh; overflow-y: auto;">
                    <h3 style="margin-bottom: 20px;">🔗 고객 병합 (같은 사람을 하나로 합치기)</h3>
                    <p style="color: #6b7280; margin-bottom: 20px;">
                        예: "김태윤"과 "김태윤(세진환즈엑서)"처럼 같은 사람이지만 다른 이름으로 거래한 경우
                    </p>
                    
                    <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 15px; align-items: center; margin-bottom: 20px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">병합할 고객 1 (메인)</label>
                            <select id="mergeCustomer1" style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 5px;">
                                <option value="">고객 선택...</option>
                                ${customerNames.map(name => `<option value="${name}">${name}</option>`).join('')}
                            </select>
                            <div id="customer1Info" style="font-size: 0.8em; color: #6b7280; margin-top: 5px;"></div>
                        </div>
                        
                        <div style="text-align: center; font-size: 1.5em; color: #7c3aed;">→</div>
                        
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">병합할 고객 2 (병합됨)</label>
                            <select id="mergeCustomer2" style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 5px;">
                                <option value="">고객 선택...</option>
                                ${customerNames.map(name => `<option value="${name}">${name}</option>`).join('')}
                            </select>
                            <div id="customer2Info" style="font-size: 0.8em; color: #6b7280; margin-top: 5px;"></div>
                        </div>
                    </div>
                    
                    <div id="mergePreview" style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px; display: none;">
                        <h4 style="margin-bottom: 10px;">병합 미리보기:</h4>
                        <div id="mergePreviewContent"></div>
                    </div>
                    
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="closeCustomerMergeModal()" class="btn btn-secondary">취소</button>
                        <button onclick="executeCustomerMerge()" class="btn" id="executeMergeBtn" disabled>병합 실행</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // 고객 선택 시 정보 표시
            document.getElementById('mergeCustomer1').addEventListener('change', updateMergePreview);
            document.getElementById('mergeCustomer2').addEventListener('change', updateMergePreview);
        }
        
        function updateMergePreview() {
            const customer1Name = document.getElementById('mergeCustomer1').value;
            const customer2Name = document.getElementById('mergeCustomer2').value;
            
            const customer1Info = document.getElementById('customer1Info');
            const customer2Info = document.getElementById('customer2Info');
            const mergePreview = document.getElementById('mergePreview');
            const executeMergeBtn = document.getElementById('executeMergeBtn');
            
            if (customer1Name && allCustomers[customer1Name]) {
                const c1 = allCustomers[customer1Name];
                customer1Info.textContent = `보증금: ₩${c1.depositAmount.toLocaleString()}, 매출: ₩${c1.salesAmount.toLocaleString()}, 거래: ${c1.transactions.length}건`;
            } else {
                customer1Info.textContent = '';
            }
            
            if (customer2Name && allCustomers[customer2Name]) {
                const c2 = allCustomers[customer2Name];
                customer2Info.textContent = `보증금: ₩${c2.depositAmount.toLocaleString()}, 매출: ₩${c2.salesAmount.toLocaleString()}, 거래: ${c2.transactions.length}건`;
            } else {
                customer2Info.textContent = '';
            }
            
            if (customer1Name && customer2Name && customer1Name !== customer2Name) {
                const c1 = allCustomers[customer1Name];
                const c2 = allCustomers[customer2Name];
                
                mergePreview.style.display = 'block';
                document.getElementById('mergePreviewContent').innerHTML = `
                    <strong>"${customer2Name}"의 모든 거래가 "${customer1Name}"으로 이동됩니다:</strong><br>
                    • 총 거래: ${c1.transactions.length + c2.transactions.length}건<br>
                    • 합계 보증금: ₩${(c1.depositAmount + c2.depositAmount).toLocaleString()}<br>
                    • 합계 매출: ₩${(c1.salesAmount + c2.salesAmount).toLocaleString()}<br>
                    <div style="color: #dc2626; margin-top: 10px;">⚠️ 이 작업은 되돌릴 수 없습니다!</div>
                `;
                executeMergeBtn.disabled = false;
            } else {
                mergePreview.style.display = 'none';
                executeMergeBtn.disabled = true;
            }
        }
        
        function executeCustomerMerge() {
            const customer1Name = document.getElementById('mergeCustomer1').value;
            const customer2Name = document.getElementById('mergeCustomer2').value;
            
            if (!customer1Name || !customer2Name || customer1Name === customer2Name) {
                showNotification('❌ 올바른 고객을 선택해주세요!');
                return;
            }
            
            if (!confirm(`정말로 "${customer2Name}"을 "${customer1Name}"으로 병합하시겠습니까?\n\n이 작업은 되돌릴 수 없습니다!`)) {
                return;
            }
            
            const customer1 = allCustomers[customer1Name];
            const customer2 = allCustomers[customer2Name];
            
            if (!customer1 || !customer2) {
                showNotification('❌ 고객 정보를 찾을 수 없습니다!');
                return;
            }
            
            // 병합 실행
            console.log(`=== 고객 병합 실행: ${customer2Name} → ${customer1Name} ===`);
            
            // 1. customer2의 모든 거래를 customer1으로 이동
            customer2.transactions.forEach(transaction => {
                // 거래의 고객명을 customer1Name으로 변경
                transaction.customer = customer1Name;
                customer1.transactions.push(transaction);
            });
            
            // 2. allTransactions에서도 고객명 변경
            allTransactions.forEach(transaction => {
                if (transaction.customer === customer2Name) {
                    transaction.customer = customer1Name;
                }
            });
            
            // 3. staffClassifications에서도 키 변경
            const newStaffClassifications = {};
            Object.keys(staffClassifications).forEach(transactionId => {
                if (transactionId.includes(`_${customer2Name}_`)) {
                    const newTransactionId = transactionId.replace(`_${customer2Name}_`, `_${customer1Name}_`);
                    newStaffClassifications[newTransactionId] = staffClassifications[transactionId];
                } else {
                    newStaffClassifications[transactionId] = staffClassifications[transactionId];
                }
            });
            staffClassifications = newStaffClassifications;
            
            // 4. customer2 삭제
            delete allCustomers[customer2Name];
            
            // 5. 전체 데이터 재분석
            analyzeCustomerData();
            
            // 6. 모든 탭 업데이트
            updateAllTabs();
            
            // 7. 저장
            saveData();
            
            showNotification(`✅ "${customer2Name}"이 "${customer1Name}"으로 성공적으로 병합되었습니다!`);
            closeCustomerMergeModal();
        }
        
        function closeCustomerMergeModal() {
            const modal = document.getElementById('customerMergeModal');
            if (modal) modal.remove();
        }
        
        // ESC 키로 모든 모달창 닫기
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeCustomerDetail();
                closeCustomerMergeModal();
            }
        });
        
        function showBoutiqueDetails(customerName) {
            // 트레이드와 동일한 상세 프로필 창 사용
            showTradeDetails(customerName);
        }
    
        function toggleCustomerDepositDetails(customerName, row) {
            const customer = allCustomers[customerName];
            
            // 현재 행이 이미 확장되어 있는지 확인
            const isCurrentlyExpanded = row.classList.contains('expanded');
            
            // 모든 기존 상세행과 expanded 상태 제거
            document.querySelectorAll('#depositsTable .detail-row').forEach(detailRow => {
                detailRow.remove();
            });
            document.querySelectorAll('#depositsTable .customer-row.expanded').forEach(expandedRow => {
                expandedRow.classList.remove('expanded');
            });

            // 같은 고객을 다시 클릭한 경우 닫기
            if (isCurrentlyExpanded) {
                return;
            }
            
            // 새로운 상세행 생성
            const table = row.parentNode.parentNode; // tbody의 부모 table
            const tbody = table.querySelector('tbody');
            const newRow = tbody.insertRow(row.rowIndex);
            newRow.className = 'detail-row';
            
            // 직원 분류가 있는 거래들 확인
            const manualClassifications = customer.transactions.map(t => {
                const tId = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                const staffClass = staffClassifications[tId];
                return { ...t, staffClass };
            });
            
            let detailHTML = `
                <td colspan="7">
                    <div style="padding: 15px;">
                        <h5 style="margin-bottom: 15px;">${customerName} 상세 거래 내역</h5>
                        
                        <!-- 요약 정보 -->
                        <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
                                <div><strong>보증금:</strong> ₩${customer.depositAmount.toLocaleString()}</div>
                                <div><strong>매출:</strong> ₩${customer.salesAmount.toLocaleString()}</div>
                                <div><strong>환급상태:</strong> ${customer.depositStatus === 'returned' ? '환급완료' : '미환급'}</div>
                                <div><strong>거래타입:</strong> ${customer.salesType === 'trade' ? '트레이드' : '부티크'}</div>
                            </div>
                            ${customer.partialRefundInfo ? `
                            <div style="margin-top: 10px; padding: 10px; background: #fef3c7; border-radius: 5px;">
                                <strong>🔄 부분환급 정보:</strong><br>
                                총 보증금: ₩${customer.partialRefundInfo.totalDeposit.toLocaleString()}, 
                                환급: ₩${customer.partialRefundInfo.partialRefund.toLocaleString()} (${customer.partialRefundInfo.refundDate}), 
                                잔액: ₩${customer.partialRefundInfo.remainingDeposit.toLocaleString()}
                            </div>
                            ` : ''}
                        </div>
                        
                        <!-- 상세 거래 테이블 -->
                        <table style="width: 100%; font-size: 0.9em;">
                            <thead>
                                <tr>
                                    <th>날짜</th>
                                    <th>유형</th>
                                    <th>금액</th>
                                    <th>자동분류</th>
                                    <th>직원분류</th>
                                    <th>최종분류</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            customer.transactions.forEach(t => {
                let autoClassification = '';
                let finalClassification = '';
                
                if (t.type === '입금') {
                    if (isTransactionDeposit(customer, t)) {
                        autoClassification = '<span class="status-badge status-deposit">보증금</span>';
                    } else {
                        autoClassification = customer.salesType === 'trade' ? 
                            '<span class="status-badge status-sales">트레이드매출</span>' : 
                            '<span class="status-badge status-sales">부티크매출</span>';
                    }
                } else {
                    if (customer.returnDate && t.date === customer.returnDate) {
                        autoClassification = '<span class="status-badge status-returned">환급</span>';
                    } else {
                        autoClassification = '<span>일반출금</span>';
                    }
                }
                
                // 직원분류 확인
                const staffClass = t.staffClass;
                let staffClassBadge = '<span style="color: #6b7280;">없음</span>';
                if (staffClass) {
                    const classLabels = {
                        'trade': '<span class="status-badge status-sales">트레이드매출</span>',
                        'boutique': '<span class="status-badge status-sales">부티크매출</span>',
                        'deposit': '<span class="status-badge status-deposit">보증금</span>',
                        'refund': '<span class="status-badge status-returned">환급</span>',
                        'actualRefund': '<span class="status-badge status-refund">환불</span>',
                        'monthlyFee': '<span class="status-badge status-excluded">월이용료</span>',
                        'exclude': '<span class="status-badge status-excluded">제외</span>'
                    };
                    staffClassBadge = classLabels[staffClass] || staffClassBadge;
                }
                
                // 최종 분류 (직원분류가 있으면 직원분류, 없으면 자동분류)
                finalClassification = staffClass ? staffClassBadge : autoClassification;
                
                detailHTML += `
                    <tr class="transaction-type-${t.type === '입금' ? 'income' : 'outcome'}">
                        <td>${t.date}</td>
                        <td>${t.type}</td>
                        <td class="amount-${t.type === '입금' ? 'positive' : 'negative'}">₩${(t.inAmount || t.outAmount).toLocaleString()}</td>
                        <td>${autoClassification}</td>
                        <td>${staffClassBadge}</td>
                        <td><strong>${finalClassification}</strong></td>
                    </tr>
                `;
            });
            
            detailHTML += `
                            </tbody>
                        </table>
                    </div>
                </td>
            `;
            
            newRow.innerHTML = detailHTML;
            row.classList.add('expanded');
        }
    
        function updateDepositsTab() {
            const tbody = document.querySelector('#depositsTable tbody');
            tbody.innerHTML = '';
            
            const depositCustomers = Object.values(allCustomers).filter(c => {
                if (c.excluded) return false;
                
                // 강효순은 보증금 관리에서 제외 (강민국과 중복이므로)
                if (specialCases[c.name] && specialCases[c.name].excludeFromDepositManagement) return false;
                
                // 직원분류가 있는 경우 직원분류를 우선으로 판단
                const hasManualDeposit = c.transactions.some(t => {
                    const tId = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                    return staffClassifications[tId] === 'deposit';
                });
                
                const hasManualClassification = c.transactions.some(t => {
                    const tId = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                    return staffClassifications[tId]; // 아무 분류든 있으면
                });
                
                // 직원분류가 있으면 보증금 분류가 있는 경우만
                if (hasManualClassification) {
                    return hasManualDeposit;
                }
                
                // 직원분류가 없으면 기존 로직 (보증금이 있거나 환급완료 이력이 있는 경우)
                return c.depositAmount > 0 || c.depositStatus === 'returned' || c.originalDepositAmount > 0;
            });
            let unreturnedAmount = 0;
            let returnedAmount = 0;
            let unreturnedCount = 0;
            let returnedCount = 0;
            let warningCount = 0;
            let warningCustomersList = [];
            
            depositCustomers.forEach(customer => {
                const row = tbody.insertRow();
                
                // 환급완료 고객의 경우 원래 보증금 금액 표시 (김진호 케이스)
                const displayDepositAmount = customer.depositStatus === 'returned' ? 
                    (customer.originalDepositAmount || specialCases[customer.name]?.depositAmount || customer.depositAmount) : 
                    customer.depositAmount;
                
                let statusBadge, returnDateText;
                if (customer.depositStatus === 'returned') {
                    statusBadge = '<span class="status-badge status-returned">환급완료</span>';
                    returnDateText = customer.returnDate ? customer.returnDate : '-';
                    returnedAmount += displayDepositAmount;
                    returnedCount++;
                } else {
                    statusBadge = '<span class="status-badge status-unreturned">미환급</span>';
                    returnDateText = '-';
                    unreturnedAmount += customer.depositAmount;
                    unreturnedCount++;
                }
                
                // 주의고객 판별: 보증금은 있지만 매출이 없는 경우
                if (customer.salesAmount === 0 && customer.depositStatus === 'unreturned') {
                    // 정익만은 실제로 매출이 있으므로 주의고객에서 제외
                    if (!(specialCases[customer.name] && specialCases[customer.name].hasSales)) {
                        warningCount++;
                        warningCustomersList.push(`${customer.name}(₩${customer.depositAmount.toLocaleString()})`);
                    }
                }
                
                row.innerHTML = `
                    <td><strong>${customer.name}</strong></td>
                    <td class="amount-negative">₩${displayDepositAmount.toLocaleString()}</td>
                    <td>${customer.depositDate || '-'}</td>
                    <td>${statusBadge}</td>
                    <td>${returnDateText}</td>
                    <td class="amount-positive">₩${customer.salesAmount.toLocaleString()}</td>
                    <td>${specialCases[customer.name]?.note || '일반 보증금'}</td>
                `;
                
                // 클릭 시 상세 거래 내역 보기
                row.style.cursor = 'pointer';
                row.addEventListener('click', () => toggleCustomerDepositDetails(customer.name, row));
            });
            
            const efficiency = unreturnedAmount > 0 ? ((depositCustomers.filter(c => c.depositStatus === 'unreturned').reduce((sum, c) => sum + c.salesAmount, 0) / unreturnedAmount) * 100).toFixed(1) : 0;
            
            document.getElementById('unreturnedDepositAmount').textContent = '₩' + unreturnedAmount.toLocaleString();
            document.getElementById('returnedDepositAmount').textContent = '₩' + returnedAmount.toLocaleString();
            document.getElementById('unreturnedDepositCount').textContent = unreturnedCount + '명 고객';
            document.getElementById('returnedDepositCount').textContent = returnedCount + '명 고객';
            document.getElementById('depositEfficiency').textContent = efficiency + '%';
            document.getElementById('depositEfficiencyDetail').textContent = `미환급 보증금 대비 매출 비율`;
            document.getElementById('warningCustomers').textContent = warningCount + '명';
            
            // 주의고객 상세 정보 표시
            const warningDetail = warningCustomersList.length > 0 ? 
                `${warningCustomersList.slice(0, 3).join(', ')}${warningCustomersList.length > 3 ? ` 외 ${warningCustomersList.length - 3}명` : ''}` : 
                '주의고객 없음';
            document.getElementById('warningCustomersDetail').textContent = warningDetail;
        }
    
        function updateSalesTab() {
            const tbody = document.querySelector('#salesTable tbody');
            tbody.innerHTML = '';
            
            const salesCustomers = Object.values(allCustomers)
                .filter(c => !c.excluded && c.salesAmount > 0) // 매출이 0 이하면 제외
                .sort((a, b) => b.salesAmount - a.salesAmount);
            
            // 매출 요약 정보 계산
            const tradeSales = salesCustomers.filter(c => c.salesType === 'trade');
            const boutiqueSales = salesCustomers.filter(c => c.salesType === 'boutique');
            const totalTradeSales = tradeSales.reduce((sum, c) => sum + c.salesAmount, 0);
            const totalBoutiqueSales = boutiqueSales.reduce((sum, c) => sum + c.salesAmount, 0);
            const totalSales = totalTradeSales + totalBoutiqueSales;
            
            // 요약 정보 표시
            const summaryGrid = document.getElementById('salesSummaryGrid');
            summaryGrid.innerHTML = `
                <div class="summary-card">
                    <div class="summary-title">🏪 트레이드 매출</div>
                    <div class="summary-value">₩${totalTradeSales.toLocaleString()}</div>
                    <div class="summary-detail">${tradeSales.length}명 고객 (${totalSales > 0 ? ((totalTradeSales/totalSales)*100).toFixed(1) : 0}%)</div>
                </div>
                <div class="summary-card">
                    <div class="summary-title">🛍️ 부티크 매출</div>
                    <div class="summary-value">₩${totalBoutiqueSales.toLocaleString()}</div>
                    <div class="summary-detail">${boutiqueSales.length}명 고객 (${totalSales > 0 ? ((totalBoutiqueSales/totalSales)*100).toFixed(1) : 0}%)</div>
                </div>
                <div class="summary-card">
                    <div class="summary-title">📊 전체 매출</div>
                    <div class="summary-value">₩${totalSales.toLocaleString()}</div>
                    <div class="summary-detail">${salesCustomers.length}명 총 고객</div>
                </div>
                <div class="summary-card">
                    <div class="summary-title">💰 평균 매출</div>
                    <div class="summary-value">₩${salesCustomers.length > 0 ? Math.round(totalSales/salesCustomers.length).toLocaleString() : '0'}</div>
                    <div class="summary-detail">고객당 평균 매출액</div>
                </div>
            `;
            
            salesCustomers.forEach(customer => {
                const row = tbody.insertRow();
                row.className = 'customer-row';
                
                const period = customer.firstTransactionDate && customer.lastTransactionDate ? 
                    (customer.firstTransactionDate.getTime() === customer.lastTransactionDate.getTime() ? 
                        customer.firstTransactionDate.toLocaleDateString('ko-KR', {year: '2-digit', month: 'numeric', day: 'numeric'}) :
                        `${customer.firstTransactionDate.toLocaleDateString('ko-KR', {year: '2-digit', month: 'numeric', day: 'numeric'})} ~ ${customer.lastTransactionDate.toLocaleDateString('ko-KR', {year: '2-digit', month: 'numeric', day: 'numeric'})}`) : 
                    '-';
                
                const incomeCount = customer.transactions.filter(t => t.type === '입금').length;
                
                // 월평균 매출 계산
                let monthlyAverage = 0;
                if (customer.firstTransactionDate && customer.lastTransactionDate) {
                    const monthsDiff = Math.max(1, Math.ceil((customer.lastTransactionDate - customer.firstTransactionDate) / (1000 * 60 * 60 * 24 * 30)));
                    monthlyAverage = Math.round(customer.salesAmount / monthsDiff);
                }
                
                let typeClass = customer.salesType || 'boutique';
                let typeBadge = typeClass === 'trade' ? 
                    '<span class="status-badge status-deposit">트레이드매출</span>' : 
                    '<span class="status-badge status-sales">부티크매출</span>';
                
                row.innerHTML = `
                    <td><strong>${customer.name}</strong></td>
                    <td class="amount-large">₩${customer.salesAmount.toLocaleString()}</td>
                    <td>${incomeCount}건</td>
                    <td style="font-size: 0.9em;">${period}</td>
                    <td>${typeBadge}</td>
                    <td class="amount-positive">₩${monthlyAverage.toLocaleString()}</td>
                    <td>${customer.depositAmount > 0 ? '₩' + customer.depositAmount.toLocaleString() : '-'}</td>
                    <td><button class="btn" style="padding: 5px 10px; font-size: 0.8em;" onclick="event.stopPropagation(); showSalesDetails('${customer.name.replace(/'/g, "\\'")}')">상세보기</button></td>
                `;
                
                row.setAttribute('data-type', typeClass);
                row.setAttribute('data-customer', customer.name);
                row.addEventListener('click', () => {
                     showTab('customers');
                     document.getElementById('customerSearch').value = customer.name;
                     filterCustomersTable(customer.name.toLowerCase(), 'all');
                });
            });
        }
    
        function showSalesDetails(customerName) {
            try {
                showTab('tradeSales');
                document.getElementById('tradeSearch').value = customerName;
                filterTradeTable(customerName.toLowerCase(), 'all');
                
                setTimeout(() => {
                    const rows = document.querySelectorAll('#tradeTable tbody tr[data-customer]');
                    const targetRow = Array.from(rows).find(r => r.getAttribute('data-customer') === customerName);
                    if (targetRow) {
                        targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            } catch (error) {
                console.error('상세보기 오류:', error);
                showNotification('❌ 상세보기 중 오류가 발생했습니다.');
            }
        }
    
        // ==========================================================
        // ▼▼▼ 월별 분석 기능 개선 ▼▼▼
        // ==========================================================
    
        function updateMonthlyTab() {
            const tbody = document.querySelector('#monthlyTable tbody');
            tbody.innerHTML = '';
            
            const salesTransactions = allTransactions.filter(t => {
                if (t.type !== '입금' || t.excluded) return false;
                const customer = allCustomers[t.customer];
                if (!customer) return false;
                
                // 보증금 거래 완전 제외 (100만원 이상 첫 입금)
                const isDepositTransaction = customer.depositAmount > 0 && t.inAmount === customer.depositAmount && t.date === customer.depositDate;
                if (isDepositTransaction) return false;
                
                // 월별 분석에서 특별 케이스 보증금도 제외
                if (specialCases[customer.name]) {
                    const specialCase = specialCases[customer.name];
                    if (specialCase.type === 'deposit_2000000' && t.inAmount >= 1000000) {
                        return false; // 김선영 200만원 보증금 (100만×2회) 제외
                    }
                    if (specialCase.type === 'linked_to_kanghyosoon' && t.inAmount >= 500000) {
                        return false; // 강민국 보증금 제외
                    }
                    if (specialCase.type === 'deposit_500000' && t.inAmount === 500000) {
                        return false; // 신범수, 정익만 보증금 제외
                    }
                    if (specialCase.type === 'deposit_100000' && t.inAmount === 100000) {
                        return false; // 김유빈 보증금 제외
                    }
                    if (specialCase.type === 'deposit_300000' && t.inAmount === 300000) {
                        return false; // 전환승 보증금 제외
                    }
                    if (specialCase.type === 'deposit_500000_returned' && t.inAmount === 500000) {
                        return false; // 최재연 보증금 제외
                    }
                    if (specialCase.type === 'deposit_refund_complete' && t.inAmount === specialCase.depositAmount) {
                        return false; // 김진호 보증금 제외
                    }
                    if (specialCase.type === 'deposit_500' && t.inAmount >= 1000000) {
                        return false; // 조태련 보증금 제외
                    }
                    if (specialCase.type === 'deposit_1000000' && t.inAmount >= 1000000) {
                        return false; // 강효순 보증금 제외
                    }
                    if (specialCase.type === 'full_refund') {
                        return false; // 테이밍랩 전액환불 제외
                    }
                }
                
                // 매출이 0 이하인 고객의 거래 제외 (환급만 받고 매출 없는 경우)
                if (customer.salesAmount <= 0) return false;
                
                return true;
            });
            
            const monthlyData = {};
            
            salesTransactions.forEach(t => {
                const yearMonth = `${t.parsedDate.getFullYear()}-${String(t.parsedDate.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[yearMonth]) {
                    monthlyData[yearMonth] = { 
                        transactions: 0, 
                        amount: 0, 
                        customers: new Set(), 
                        newCustomers: new Set(),
                        tradeAmount: 0,
                        boutiqueAmount: 0,
                        tradeCount: 0,
                        boutiqueCount: 0
                    };
                }
                
                const customer = allCustomers[t.customer];
                const isTradeTransaction = customer && (customer.salesType === 'trade' || customer.depositAmount > 0);
                
                monthlyData[yearMonth].transactions++;
                monthlyData[yearMonth].amount += t.inAmount;
                monthlyData[yearMonth].customers.add(t.customer);
                
                if (isTradeTransaction) {
                    monthlyData[yearMonth].tradeAmount += t.inAmount;
                    monthlyData[yearMonth].tradeCount++;
                } else {
                    monthlyData[yearMonth].boutiqueAmount += t.inAmount;
                    monthlyData[yearMonth].boutiqueCount++;
                }
                
                if (customer && customer.firstTransactionDate && customer.firstTransactionDate.getFullYear() === t.parsedDate.getFullYear() && customer.firstTransactionDate.getMonth() === t.parsedDate.getMonth()) {
                    monthlyData[yearMonth].newCustomers.add(t.customer);
                }
            });
            
            const sortedMonths = Object.keys(monthlyData).sort().reverse();
            let previousAmount = 0;
            
            sortedMonths.forEach((month, index) => {
                const data = monthlyData[month];
                const prevMonthKey = sortedMonths[index + 1];
                previousAmount = prevMonthKey ? monthlyData[prevMonthKey].amount : 0;
                const avgAmount = data.transactions > 0 ? data.amount / data.transactions : 0;
                const growthRate = previousAmount > 0 ? ((data.amount - previousAmount) / previousAmount * 100).toFixed(1) : '0.0';
                
                const row = tbody.insertRow();
                row.className = 'customer-row'; // 클릭 가능하게 스타일 적용
                row.setAttribute('data-month', month);
    
                const tradeVsBoutique = `T:₩${data.tradeAmount.toLocaleString()} / B:₩${data.boutiqueAmount.toLocaleString()}`;
                
                row.innerHTML = `
                    <td><strong>${month}</strong></td>
                    <td>${data.transactions}건</td>
                    <td class="amount-positive">₩${data.amount.toLocaleString()}</td>
                    <td style="font-size: 0.8em;">${tradeVsBoutique}</td>
                    <td>${data.newCustomers.size}명</td>
                    <td>₩${Math.round(avgAmount).toLocaleString()}</td>
                    <td style="color: ${parseFloat(growthRate) >= 0 ? '#059669' : '#dc2626'}">${growthRate >= 0 ? '▲' : '▼'} ${growthRate}%</td>
                `;
                
                // 월별 상세보기를 위한 클릭 이벤트 추가
                row.addEventListener('click', () => toggleMonthDetails(month, row));
            });
        }
    
        // 월별 상세 거래내역을 보여주는 새로운 함수
        function toggleMonthDetails(month, row) {
            // 현재 행이 이미 확장되어 있는지 확인
            const isCurrentlyExpanded = row.classList.contains('expanded');
            
            // 모든 기존 상세행과 expanded 상태 제거
            document.querySelectorAll('#monthlyTable .detail-row').forEach(detailRow => {
                detailRow.remove();
            });
            document.querySelectorAll('#monthlyTable .customer-row.expanded').forEach(expandedRow => {
                expandedRow.classList.remove('expanded');
            });

            // 같은 월을 다시 클릭한 경우 닫기
            if (isCurrentlyExpanded) {
                return;
            }

            const [year, monthNum] = month.split('-').map(Number);
    
            const monthSalesTransactions = allTransactions.filter(t => {
                if (t.type !== '입금' || t.excluded || !t.parsedDate) return false;
                if (t.parsedDate.getFullYear() !== year || t.parsedDate.getMonth() + 1 !== monthNum) return false;
                
                const customer = allCustomers[t.customer];
                if (!customer) return false;
                
                // 보증금 거래 제외
                return !(customer.depositAmount > 0 && t.inAmount === customer.depositAmount && t.date === customer.depositDate);
            }).sort((a,b) => b.parsedDate - a.parsedDate);
    
            let detailHTML = `<td colspan="7"><div style="padding: 15px;">
                <h5 style="margin-bottom: 10px;">${month} 매출 상세 내역 (${monthSalesTransactions.length}건)</h5>
                <table style="width: 100%; font-size: 0.9em;">
                    <thead><tr><th>날짜</th><th>고객명</th><th>매출액</th><th>타입</th></tr></thead>
                    <tbody>`;
    
            monthSalesTransactions.forEach(t => {
                const customer = allCustomers[t.customer];
                const isTradeTransaction = customer && (customer.salesType === 'trade' || customer.depositAmount > 0);
                const typeLabel = isTradeTransaction ? 'T' : 'B';
                
                detailHTML += `
                    <tr class="transaction-type-income">
                        <td>${t.date}</td>
                        <td><strong>${t.customer}</strong></td>
                        <td class="amount-positive">₩${t.inAmount.toLocaleString()}</td>
                        <td style="font-weight: bold; color: ${isTradeTransaction ? '#7c3aed' : '#059669'}">${typeLabel}</td>
                    </tr>
                `;
            });
    
            detailHTML += `</tbody></table></div></td>`;
            
            // 새로운 상세행 생성 (기존 방식 대신)
            const table = row.parentNode.parentNode; // tbody의 부모 table
            const tbody = table.querySelector('tbody');
            const newRow = tbody.insertRow(row.rowIndex);
            newRow.className = 'detail-row';
            newRow.innerHTML = detailHTML;
            
            row.classList.add('expanded');
        }
        
        // ==========================================================
        // ▲▲▲ 월별 분석 기능 개선 ▲▲▲
        // ==========================================================
        
        function updateTransactionsTab() {
            const tbody = document.querySelector('#transactionsTable tbody');
            tbody.innerHTML = '';
            
            let classifiedCount = 0;
            let unclassifiedCount = 0;
            let tradeClassifiedCount = 0;
            let boutiqueClassifiedCount = 0;
            
            // 성능 최적화: 거래 분류 정보를 미리 캐시
            const transactionClassificationCache = {};
            
            console.log('거래 탭 업데이트 시작');
            
            // 배치 처리로 DOM 업데이트 최적화
            const fragment = document.createDocumentFragment();
            
            allTransactions.forEach((t, index) => {
                try {
                    const row = document.createElement('tr');
                    row.className = `transaction-type-${t.type === '입금' ? 'income' : 'outcome'}`;
                    
                    let autoClassification = '';
                    let staffClassification = '';
                    
                    // 캐시된 분류 정보 사용 또는 계산
                    const cacheKey = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                    
                    if (!transactionClassificationCache[cacheKey]) {
                        if (t.excluded) {
                            autoClassification = '<span class="status-badge status-excluded">제외</span>';
                            classifiedCount++;
                        } else {
                            const customer = allCustomers[t.customer];
                            if (customer) {
                                if (t.type === '입금') {
                                    // 성능 최적화: 간단한 보증금 판별 (복잡한 로직 최소화)
                                    const isDeposit = customer.depositAmount > 0 && 
                                                    t.inAmount >= 100000 && 
                                                    t.date === customer.depositDate;
                                    
                                    if (isDeposit) {
                                        autoClassification = '<span class="status-badge status-deposit">보증금</span>';
                                    } else {
                                        if (customer.salesType === 'trade') {
                                            autoClassification = '<span class="status-badge status-sales">트레이드매출</span>';
                                            tradeClassifiedCount++;
                                        } else {
                                            autoClassification = '<span class="status-badge status-sales">부티크매출</span>';
                                            boutiqueClassifiedCount++;
                                        }
                                    }
                                    classifiedCount++;
                                } else if (t.type === '출금' && customer.returnDate && t.date === customer.returnDate) {
                                    autoClassification = '<span class="status-badge status-returned">환급</span>';
                                    classifiedCount++;
                                } else {
                                    // 직원분류에 월이용료가 지정된 출금/입금 처리
                                    const tIdTmp = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                                    if (staffClassifications[tIdTmp] === 'monthlyFee') {
                                        autoClassification = '<span class="status-badge status-excluded">월이용료</span>';
                                    } else {
                                        autoClassification = '<span>일반출금</span>';
                                    }
                                    classifiedCount++;
                                }
                            } else {
                                unclassifiedCount++;
                            }
                        }
                        
                        // 결과 캐시
                        transactionClassificationCache[cacheKey] = autoClassification;
                    } else {
                        autoClassification = transactionClassificationCache[cacheKey];
                        if (autoClassification.includes('제외')) classifiedCount++;
                        else if (autoClassification.includes('트레이드매출')) { classifiedCount++; tradeClassifiedCount++; }
                        else if (autoClassification.includes('부티크매출')) { classifiedCount++; boutiqueClassifiedCount++; }
                        else if (autoClassification.includes('보증금') || autoClassification.includes('환급') || autoClassification.includes('일반출금') || autoClassification.includes('월이용료')) classifiedCount++;
                        else unclassifiedCount++;
                    }
                    
                    // 직원 분류 수정 가능한 드롭다운
                    const transactionId = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`.replace(/'/g, "\\'");
                    const currentClassification = staffClassifications[transactionId] || '';
                    
                    // 직원 분류가 있으면 그것을 우선으로 표시
                    if (currentClassification) {
                        const classificationLabels = {
                            'trade': '<span class="status-badge status-sales">트레이드매출</span>',
                            'boutique': '<span class="status-badge status-sales">부티크매출</span>',
                            'deposit': '<span class="status-badge status-deposit">보증금</span>',
                            'refund': '<span class="status-badge status-returned">환급</span>',
                            'actualRefund': '<span class="status-badge status-refund">환불</span>',
                            'monthlyFee': '<span class="status-badge status-excluded">월이용료</span>',
                            'exclude': '<span class="status-badge status-excluded">제외</span>'
                        };
                        autoClassification = classificationLabels[currentClassification] || autoClassification;
                    }
                    
                    staffClassification = `
                        <select id="staff_${transactionId}" onchange="updateStaffClassification('${transactionId}', this.value)" style="font-size: 0.8em;">
                            <option value="" ${currentClassification === '' ? 'selected' : ''}>자동분류</option>
                            <option value="trade" ${currentClassification === 'trade' ? 'selected' : ''}>트레이드매출</option>
                            <option value="boutique" ${currentClassification === 'boutique' ? 'selected' : ''}>부티크매출</option>
                            <option value="deposit" ${currentClassification === 'deposit' ? 'selected' : ''}>보증금</option>
                            <option value="refund" ${currentClassification === 'refund' ? 'selected' : ''}>환급</option>
                            <option value="actualRefund" ${currentClassification === 'actualRefund' ? 'selected' : ''}>환불</option>
                            <option value="monthlyFee" ${currentClassification === 'monthlyFee' ? 'selected' : ''}>월이용료</option>
                            <option value="exclude" ${currentClassification === 'exclude' ? 'selected' : ''}>제외</option>
                        </select>
                    `;
                    
                    row.innerHTML = `
                        <td>${t.date}</td>
                        <td><strong>${t.customer}</strong></td>
                        <td class="amount-positive">${t.type === '입금' ? '₩' + t.inAmount.toLocaleString() : '-'}</td>
                        <td class="amount-negative">${t.type === '출금' ? '₩' + t.outAmount.toLocaleString() : '-'}</td>
                        <td>${autoClassification}</td>
                        <td>${staffClassification}</td>
                        <td><input type="text" placeholder="비고" style="width: 100px; font-size: 0.8em;"></td>
                        <td><span style="font-size: 0.8em; color: #059669;">실시간 반영</span></td>
                    `;
                    
                    row.setAttribute('data-type', t.type.replace('금',''));
                    row.setAttribute('data-customer', t.customer);
                    row.setAttribute('data-amount', t.inAmount || t.outAmount);
                    row.setAttribute('data-date', t.date);
                    row.setAttribute('data-id', transactionId);
                    
                    fragment.appendChild(row);
                } catch (error) {
                    console.warn('거래 처리 오류:', error, t);
                    unclassifiedCount++;
                }
            });
            
            // 한 번에 DOM에 추가 (성능 최적화)
            tbody.appendChild(fragment);
            
            // 분류 통계 업데이트
            document.getElementById('classifiedCount').textContent = classifiedCount.toLocaleString() + '건';
            document.getElementById('unclassifiedCount').textContent = unclassifiedCount.toLocaleString() + '건';
            document.getElementById('tradeClassifiedCount').textContent = tradeClassifiedCount.toLocaleString() + '건';
            document.getElementById('boutiqueClassifiedCount').textContent = boutiqueClassifiedCount.toLocaleString() + '건';
            
            console.log('거래 탭 업데이트 완료');
        }
    
        // 직원 분류 업데이트 함수들 (성능 최적화)
        function updateStaffClassification(transactionId, classification) {
            console.log(`=== 직원분류 변경: ${transactionId} → ${classification} ===`);
            
            // 직원 분류 저장
            staffClassifications[transactionId] = classification;
            
            // 거래 ID에서 고객명 추출
            const parts = transactionId.split('_');
            if (parts.length >= 2) {
                const customerName = parts[1];
                console.log(`고객명: ${customerName} 처리 시작`);
                
                // 해당 고객이 존재하는지 확인
                if (allCustomers[customerName]) {
                    // 즉시 해당 고객만 재계산 (최적화)
                    recalculateCustomerDataOnly(allCustomers[customerName]);
                    console.log(`${customerName} 재계산 완료`);
                    
                    // 해당 고객이 관련된 테이블만 업데이트 (전체 업데이트 대신)
                    updateSpecificCustomerInTables(customerName);
                }
            }
            
            // 로컬 스토리지에 저장
            saveData();
            
            console.log(`거래 ${transactionId}의 분류를 ${classification || '자동분류'}로 변경 - 완료`);
            
            // 사용자에게 알림
            const displayClassification = classification || '자동분류';
            const customerName = parts.length >= 2 ? parts[1] : '고객';
            showNotification(`✅ ${customerName} 분류가 ${displayClassification}로 변경되었습니다!`);
        }
        
        // 특정 고객만 테이블에서 업데이트 (성능 최적화)
        function updateSpecificCustomerInTables(customerName) {
            const customer = allCustomers[customerName];
            if (!customer) return;
            
            // 보증금 관리 테이블에서 해당 고객 행만 업데이트
            const depositRows = document.querySelectorAll('#depositsTable tbody tr');
            depositRows.forEach(row => {
                const rowCustomerName = row.cells[0].textContent.trim();
                if (rowCustomerName === customerName) {
                    // 해당 행만 업데이트
                    row.cells[1].innerHTML = `<span class="amount-negative">₩${customer.depositAmount.toLocaleString()}</span>`;
                    row.cells[5].innerHTML = `<span class="amount-positive">₩${customer.salesAmount.toLocaleString()}</span>`;
                }
            });
            
            // CEO 대시보드 요약 수치만 업데이트
            updateHeaderStatsOnly();
        }
        
        // 헤더 통계만 업데이트 (빠른 업데이트)
        function updateHeaderStatsOnly() {
            const nonExcludedCustomers = Object.values(allCustomers).filter(c => !c.excluded);
            const totalSales = nonExcludedCustomers.reduce((sum, c) => sum + c.salesAmount, 0);
            const totalDeposits = nonExcludedCustomers.reduce((sum, c) => sum + c.depositAmount, 0);
            
            document.getElementById('finalSalesAmount').textContent = '₩' + totalSales.toLocaleString();
            
            // CEO 대시보드 수치 업데이트
            if (document.getElementById('ceoDashboardTotalSales')) {
                document.getElementById('ceoDashboardTotalSales').textContent = '₩' + totalSales.toLocaleString();
                document.getElementById('ceoDashboardTotalDeposits').textContent = '₩' + totalDeposits.toLocaleString();
            }
        }
        
        // 개별 고객만 재계산하는 함수 (analyzeCustomerData 호출 안 함)
        function recalculateCustomerDataOnly(customer) {
            console.log(`=== ${customer.name} 단독 재계산 시작 ===`);
            
            // 이유진 복잡한 케이스 특별 처리
            if (customer.name === '이유진' && specialCases[customer.name] && specialCases[customer.name].type === 'complex_deposit_case') {
                console.log('이유진 복잡한 케이스 - 특별 처리');
                const specialCase = specialCases[customer.name];
                
                // 실제 매출 = 총 매출 - 환불 금액
                customer.salesAmount = Math.max(0, customer.totalIncome - specialCase.actualRefund);
                customer.salesType = 'trade';
                customer.depositAmount = specialCase.depositAmount;
                customer.depositStatus = 'unreturned';
                customer.returnDate = null;
                
                // 복잡한 케이스 정보 저장
                customer.complexCaseInfo = {
                    originalDeposit: specialCase.depositAmount,
                    monthlyFeeDeduction: specialCase.monthlyFeeDeduction,
                    actualRefund: specialCase.actualRefund,
                    remainingDeposit: Math.max(0, specialCase.depositAmount - specialCase.monthlyFeeDeduction),
                    actualSales: customer.salesAmount
                };
                
                console.log(`이유진 복잡한 케이스 최종: 보증금=${customer.depositAmount}, 실제매출=${customer.salesAmount}, 환불=${specialCase.actualRefund}`);
                return;
            }
            
            // 신수연 부분환급 특별 처리
            if (customer.name === '신수연' && specialCases[customer.name] && specialCases[customer.name].type === 'partial_refund') {
                console.log('신수연 부분환급 케이스 - 특별 처리');
                const specialCase = specialCases[customer.name];
                
                let manualDepositAmount = 0;
                let manualSalesAmount = 0;
                let hasManualClassification = false;
                
                // 직원분류 확인
                customer.transactions.forEach(t => {
                    const tId = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                    const staffClass = staffClassifications[tId];
                    
                    if (staffClass) {
                        hasManualClassification = true;
                        console.log(`거래 ${t.date} ${t.inAmount || t.outAmount}: ${staffClass}`);
                        
                        if (staffClass === 'deposit' && t.type === '입금') {
                            manualDepositAmount += t.inAmount;
                        } else if ((staffClass === 'trade' || staffClass === 'boutique') && t.type === '입금') {
                            manualSalesAmount += t.inAmount;
                        }
                    }
                });
                
                if (hasManualClassification) {
                    // 부분환급 정보 적용
                    customer.depositAmount = specialCase.remainingDeposit; // 잔액 500만원 (고정)
                    customer.salesAmount = manualSalesAmount; // 직원이 매출로 분류한 금액
                    customer.depositStatus = 'unreturned';
                    customer.depositDate = customer.transactions.find(t => t.type === '입금').date;
                    customer.salesType = 'trade';
                    customer.partialRefundInfo = {
                        totalDeposit: specialCase.totalDeposit,
                        partialRefund: specialCase.partialRefund,
                        refundDate: specialCase.refundDate,
                        remainingDeposit: specialCase.remainingDeposit
                    };
                    
                    console.log(`신수연 부분환급 최종: 보증금=${customer.depositAmount}, 매출=${customer.salesAmount}`);
                    return;
                }
            }
            
            // 일반 고객 처리
            let manualDepositAmount = 0;
            let manualSalesAmount = 0;
            let manualMonthlyFeeAmount = 0;
            let manualRefundAmount = 0;
            let hasManualClassification = false;
            let depositTransactionDate = null;
            
            // 모든 거래에 대해 직원 분류 확인
            customer.transactions.forEach(t => {
                const tId = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                const staffClass = staffClassifications[tId];
                
                if (staffClass) {
                    hasManualClassification = true;
                    console.log(`거래 ${t.date} ${t.inAmount || t.outAmount}: ${staffClass}`);
                    
                    if (staffClass === 'deposit' && t.type === '입금') {
                        manualDepositAmount += t.inAmount;
                        if (!depositTransactionDate) depositTransactionDate = t.date;
                    } else if ((staffClass === 'trade' || staffClass === 'boutique') && t.type === '입금') {
                        manualSalesAmount += t.inAmount;
                    } else if (staffClass === 'monthlyFee') {
                        manualMonthlyFeeAmount += (t.inAmount || t.outAmount || 0);
                    } else if (staffClass === 'refund') {
                        manualRefundAmount += (t.outAmount || t.inAmount || 0);
                    }
                    // exclude는 아무것도 더하지 않음
                }
            });
            
            // 직원 분류가 있으면 완전히 덮어쓰기
            if (hasManualClassification) {
                console.log(`직원분류 적용: 보증금=${manualDepositAmount}, 매출=${manualSalesAmount}`);
                
                // 기존 자동분류 데이터 완전 초기화
                customer.depositAmount = manualDepositAmount;
                // 보증금 잔액 = 보증금 - 환불 - 월이용료
                customer.depositAmount = Math.max(0, manualDepositAmount - manualRefundAmount - manualMonthlyFeeAmount);
                customer.salesAmount = manualSalesAmount;
                customer.depositDate = depositTransactionDate;
                
                // 보증금 상태 재설정
                if (customer.depositAmount > 0) {
                    customer.depositStatus = 'unreturned';
                } else {
                    customer.depositStatus = 'none';
                    customer.depositDate = null;
                }
                
                // 매출 타입 결정
                const hasTradeClass = customer.transactions.some(t => {
                    const tId = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                    return staffClassifications[tId] === 'trade';
                });
                const hasBoutiqueClass = customer.transactions.some(t => {
                    const tId = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                    return staffClassifications[tId] === 'boutique';
                });
                
                if (hasTradeClass) customer.salesType = 'trade';
                else if (hasBoutiqueClass) customer.salesType = 'boutique';
                else customer.salesType = 'boutique'; // 기본값
                
                console.log(`${customer.name} 최종 결과: 보증금=${customer.depositAmount}, 매출=${customer.salesAmount}, 타입=${customer.salesType}`);
            }
        }
        
        // 고객별 분류 업데이트 함수
        function updateCustomerClassification(customerName, transactionId, classification, amount) {
            const customer = allCustomers[customerName];
            if (!customer) return;
            
            // 해당 거래를 찾아서 수동 분류 표시 추가
            const transaction = customer.transactions.find(t => {
                const tId = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                return tId === transactionId;
            });
            
            if (transaction) {
                transaction.manualClassification = classification;
            }
            
            // 직원 분류에 따라 고객 데이터 완전히 재계산
            recalculateCustomerData(customer);
        }
        
        // 고객 데이터 완전 재계산 함수
        function recalculateCustomerData(customer) {
            console.log(`=== ${customer.name} 데이터 재계산 (직원분류 우선) ===`);
            
            let manualDepositAmount = 0;
            let manualSalesAmount = 0;
            let manualMonthlyFeeAmount = 0;
            let manualRefundAmount = 0;
            let hasManualClassification = false;
            let depositTransactionDate = null;
            
            // 모든 거래에 대해 직원 분류 확인
            customer.transactions.forEach(t => {
                const tId = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                const staffClass = staffClassifications[tId];
                
                if (staffClass) {
                    hasManualClassification = true;
                    console.log(`거래 ${t.date} ${t.inAmount || t.outAmount}: ${staffClass}`);
                    
                    if (staffClass === 'deposit' && t.type === '입금') {
                        manualDepositAmount += t.inAmount;
                        if (!depositTransactionDate) depositTransactionDate = t.date;
                    } else if ((staffClass === 'trade' || staffClass === 'boutique') && t.type === '입금') {
                        manualSalesAmount += t.inAmount;
                    } else if (staffClass === 'monthlyFee') {
                        manualMonthlyFeeAmount += (t.inAmount || t.outAmount || 0);
                    } else if (staffClass === 'refund') {
                        manualRefundAmount += (t.outAmount || t.inAmount || 0);
                    }
                    // exclude는 아무것도 더하지 않음
                }
            });
            
            // 직원 분류가 있으면 완전히 덮어쓰기
            if (hasManualClassification) {
                console.log(`직원분류 적용: 보증금=${manualDepositAmount}, 매출=${manualSalesAmount}`);
                
                // 기존 자동분류 데이터 완전 초기화
                customer.depositAmount = Math.max(0, manualDepositAmount - manualRefundAmount - manualMonthlyFeeAmount);
                customer.salesAmount = manualSalesAmount;
                customer.depositDate = depositTransactionDate;
                
                // 보증금 상태 재설정
                if (customer.depositAmount > 0) {
                    customer.depositStatus = 'unreturned';
                } else {
                    customer.depositStatus = 'none';
                    customer.depositDate = null;
                }
                
                // 매출 타입 결정
                const hasTradeClass = customer.transactions.some(t => {
                    const tId = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                    return staffClassifications[tId] === 'trade';
                });
                const hasBoutiqueClass = customer.transactions.some(t => {
                    const tId = `${t.date}_${t.customer}_${t.inAmount || t.outAmount}`;
                    return staffClassifications[tId] === 'boutique';
                });
                
                if (hasTradeClass) customer.salesType = 'trade';
                else if (hasBoutiqueClass) customer.salesType = 'boutique';
                else customer.salesType = 'boutique'; // 기본값
                
                console.log(`최종 결과: 보증금=${customer.depositAmount}, 매출=${customer.salesAmount}, 타입=${customer.salesType}`);
            }
        }
        
        function saveTransactionClassification(transactionId) {
            const selectElement = document.getElementById(`staff_${transactionId}`);
            const noteElement = document.querySelector(`tr[data-id="${transactionId}"] input[type="text"]`);
            
            if (selectElement) {
                const classification = selectElement.value;
                const note = noteElement ? noteElement.value : '';
                
                // 직원 분류 저장
                staffClassifications[transactionId] = classification;
                
                // 비고도 저장 (필요시)
                if (note) {
                    if (!window.transactionNotes) window.transactionNotes = {};
                    window.transactionNotes[transactionId] = note;
                }
                
                // 거래 ID에서 고객명 추출하여 데이터 즉시 업데이트
                const parts = transactionId.split('_');
                if (parts.length >= 2) {
                    const customerName = parts[1];
                    if (allCustomers[customerName]) {
                        // 전체 데이터 재분석 및 모든 탭 업데이트
                        analyzeCustomerData();
                        updateAllTabs();
                        
                        // 로컬 스토리지에 저장
                        saveData();
                        
                        console.log(`✅ ${customerName} 거래 분류를 ${classification || '자동분류'}로 변경하여 전체에 반영`);
                        showNotification(`✅ ${customerName} 거래가 ${classification || '자동분류'}로 변경되어 모든 탭에 즉시 반영되었습니다!`);
                        return;
                    }
                }
            }
            
            showNotification('✅ 분류가 저장되었습니다.');
        }
        
        function exportClassificationData() {
            const classificationData = {
                timestamp: new Date().toISOString(),
                classifications: []
            };
            
            const blob = new Blob([JSON.stringify(classificationData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `거래분류_${new Date().toISOString().substring(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification('✅ 분류 데이터가 내보내졌습니다!');
        }
        
        function importClassificationData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const data = JSON.parse(e.target.result);
                            console.log('분류 데이터 가져오기:', data);
                            showNotification('✅ 분류 데이터를 가져왔습니다!');
                        } catch (error) {
                            showNotification('❌ 파일 형식이 올바르지 않습니다.');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }
        
        function updateUploadHistory() {
            const historyContainer = document.getElementById('uploadHistory');
            if (uploadHistory.length === 0) {
                historyContainer.innerHTML = '<p style="color: #6b7280;">아직 업로드된 파일이 없습니다.</p>';
                return;
            }
            
            const historyHTML = uploadHistory.map((upload, index) => `
                <div style="background: #f9fafb; padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>${upload.fileName}</strong>
                            <span style="color: #6b7280; margin-left: 10px;">
                                ${upload.uploadTime.toLocaleString()}
                            </span>
                        </div>
                        <div style="text-align: right;">
                            <div style="color: #059669;">+${upload.addedCount}건 추가</div>
                            <div style="font-size: 0.9em; color: #6b7280;">총 ${upload.transactionCount}건</div>
                        </div>
                    </div>
                </div>
            `).join('');
            
            historyContainer.innerHTML = historyHTML;
        }
    
        function filterTable(filterId) {
            if (filterId.includes('deposit')) {
                const searchInput = document.getElementById('depositSearch');
                const filterSelect = document.getElementById('depositFilter');
                
                const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
                const filterValue = filterSelect ? filterSelect.value : 'all';
                
                filterDepositsTable(searchTerm, filterValue);
            } else if (filterId.includes('trade')) {
                const searchInput = document.getElementById('tradeSearch');
                const filterSelect = document.getElementById('tradeFilter');
                
                const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
                const filterValue = filterSelect ? filterSelect.value : 'all';
                
                filterTradeTable(searchTerm, filterValue);
            } else if (filterId.includes('boutique')) {
                const searchInput = document.getElementById('boutiqueSearch');
                const filterSelect = document.getElementById('boutiqueFilter');
                
                const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
                const filterValue = filterSelect ? filterValue.value : 'all';
                
                filterBoutiqueTable(searchTerm, filterValue);
            } else if (filterId.includes('transaction')) {
                const searchInput = document.getElementById('transactionSearch');
                const filterSelect = document.getElementById('transactionFilter');
                
                const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
                const filterValue = filterSelect ? filterSelect.value : 'all';
                
                filterTransactionsTable(searchTerm, filterValue);
            }
        }
    
        function filterDepositsTable(searchTerm, filterValue) {
            const sortValue = document.getElementById('depositSort')?.value || 'deposit_desc';
            const rows = Array.from(document.querySelectorAll('#depositsTable tbody tr'));
            
            // 먼저 필터링 (빠른 처리)
            const visibleRows = rows.filter(row => {
                if (!row.cells || row.cells.length < 2) return false;
                
                const customerName = row.cells[0].textContent.toLowerCase();
                const depositAmountText = row.cells[1].textContent;
                const depositAmount = parseInt(depositAmountText.replace(/[₩,]/g, '')) || 0;
                const statusText = row.cells[3]?.textContent || '';
                
                let showRow = true;
                if (searchTerm && !customerName.includes(searchTerm)) showRow = false;
                
                switch (filterValue) {
                    case 'active': if (!statusText.includes('미환급')) showRow = false; break;
                    case 'returned': if (!statusText.includes('환급완료')) showRow = false; break;
                    case 'large': if (depositAmount < 5000000) showRow = false; break;
                }
                
                if (showRow) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
                
                return showRow;
            });
            
            // 정렬 적용 (표시되는 행들만)
            if (visibleRows.length > 0) {
                visibleRows.sort((a, b) => {
                    try {
                        switch (sortValue) {
                            case 'deposit_desc':
                                const amountA = parseInt(a.cells[1].textContent.replace(/[₩,]/g, '')) || 0;
                                const amountB = parseInt(b.cells[1].textContent.replace(/[₩,]/g, '')) || 0;
                                return amountB - amountA;
                            case 'deposit_asc':
                                const amountA2 = parseInt(a.cells[1].textContent.replace(/[₩,]/g, '')) || 0;
                                const amountB2 = parseInt(b.cells[1].textContent.replace(/[₩,]/g, '')) || 0;
                                return amountA2 - amountB2;
                            case 'date_desc':
                            case 'deposit_date_desc':
                                const dateA = new Date(a.cells[2].textContent || '1900-01-01');
                                const dateB = new Date(b.cells[2].textContent || '1900-01-01');
                                return dateB - dateA;
                            case 'date_asc':
                            case 'deposit_date_asc':
                                const dateA2 = new Date(a.cells[2].textContent || '1900-01-01');
                                const dateB2 = new Date(b.cells[2].textContent || '1900-01-01');
                                return dateA2 - dateB2;
                            default:
                                return 0;
                        }
                    } catch (error) {
                        console.warn('정렬 오류:', error);
                        return 0;
                    }
                });
                
                // 테이블에 다시 삽입
                const tbody = document.querySelector('#depositsTable tbody');
                if (tbody) {
                    visibleRows.forEach(row => tbody.appendChild(row));
                }
            }
        }
        
        function filterTradeTable(searchTerm, filterValue) {
            const rows = document.querySelectorAll('#tradeTable tbody tr');
            rows.forEach(row => {
                const customerName = row.cells[0].textContent.toLowerCase();
                const salesAmount = parseInt(row.cells[1].textContent.replace(/[₩,]/g, ''));
                
                let showRow = true;
                if (searchTerm && !customerName.includes(searchTerm)) showRow = false;
                
                switch (filterValue) {
                    case 'high': if (salesAmount < 5000000) showRow = false; break;
                    case 'medium': if (salesAmount < 1000000 || salesAmount >= 5000000) showRow = false; break;
                    case 'low': if (salesAmount >= 1000000) showRow = false; break;
                }
                row.style.display = showRow ? '' : 'none';
            });
        }
        
        function filterBoutiqueTable(searchTerm, filterValue) {
            const rows = document.querySelectorAll('#boutiqueTable tbody tr');
            rows.forEach(row => {
                const customerName = row.cells[0].textContent.toLowerCase();
                const salesAmount = parseInt(row.cells[1].textContent.replace(/[₩,]/g, ''));
                
                let showRow = true;
                if (searchTerm && !customerName.includes(searchTerm)) showRow = false;
                
                switch (filterValue) {
                    case 'high': if (salesAmount < 2000000) showRow = false; break;
                    case 'medium': if (salesAmount < 500000 || salesAmount >= 2000000) showRow = false; break;
                    case 'low': if (salesAmount >= 500000) showRow = false; break;
                }
                row.style.display = showRow ? '' : 'none';
            });
        }
    
        function filterTransactionsTable(searchTerm, filterValue) {
            const rows = document.querySelectorAll('#transactionsTable tbody tr');
            let visibleCount = 0;
            
            // 빠른 필터링 (DOM 조작 최소화)
            rows.forEach(row => {
                try {
                    const date = row.getAttribute('data-date') || '';
                    const customerName = (row.getAttribute('data-customer') || '').toLowerCase();
                    const type = row.getAttribute('data-type') || '';
                    const amount = parseInt(row.getAttribute('data-amount')) || 0;
                    
                    let showRow = true;
                    
                    // 검색어 필터 (빠른 체크)
                    if (searchTerm && !customerName.includes(searchTerm) && !date.includes(searchTerm)) {
                        showRow = false;
                    }
                    
                    // 타입 필터
                    if (showRow) {
                        switch (filterValue) {
                            case 'income': 
                                if (type !== '입') showRow = false; 
                                break;
                            case 'outcome': 
                                if (type !== '출') showRow = false; 
                                break;
                            case 'large': 
                                if (amount < 1000000) showRow = false; 
                                break;
                            case 'recent':
                                const transactionDate = new Date(date);
                                const thirtyDaysAgo = new Date();
                                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                                if (transactionDate < thirtyDaysAgo) showRow = false;
                                break;
                            case 'unclassified':
                                // 미분류 조건 체크는 더 복잡하므로 생략하고 빠른 처리
                                break;
                        }
                    }
                    
                    // DOM 업데이트 (한 번만)
                    if (showRow) {
                        if (row.style.display === 'none') row.style.display = '';
                        visibleCount++;
                    } else {
                        if (row.style.display !== 'none') row.style.display = 'none';
                    }
                } catch (error) {
                    console.warn('필터링 오류:', error);
                    row.style.display = '';
                }
            });
            
            console.log(`거래 필터링 완료: ${visibleCount}/${rows.length}건 표시`);
        }
            function showTab(tabName) {
                // 모든 탭에서 active 클래스 제거
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                
                // 모든 탭 콘텐츠에서 active 클래스 제거
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                // 클릭된 탭에 active 클래스 추가
                const activeTab = document.querySelector(`.tab[onclick*="'${tabName}'"]`);
                if (activeTab) {
                    activeTab.classList.add('active');
                }
                
                // 해당 탭 콘텐츠 활성화
                const activeContent = document.getElementById(tabName);
                if (activeContent) {
                    activeContent.classList.add('active');
                }
                
                // 탭 변경 시 필요한 업데이트 수행
                if (analysisComplete) {
                    switch(tabName) {
                        case 'ceoDashboard':
                            updateCEODashboard();
                            break;
                        case 'deposits':
                            updateDepositsTab();
                            break;
                        case 'tradeSales':
                            updateTradeSalesTab();
                            break;
                        case 'boutiqueSales':
                            updateBoutiqueSalesTab();
                            break;
                        case 'monthly':
                            updateMonthlyTab();
                            break;
                        case 'transactions':
                            updateTransactionsTab();
                            break;
                    }
                }
            }
    
            function clearData() {
                if (confirm('정말로 모든 데이터를 초기화하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
                    allTransactions = [];
                    allCustomers = {};
                    uploadHistory = [];
                    staffClassifications = {};
                    analysisComplete = false;
                    
                    localStorage.removeItem(STORAGE_KEY);
                    
                    updateAllTabs();
                    document.getElementById('uploadStatus').innerHTML = '';
                    document.getElementById('analyzeBtn').disabled = true;
                    
                    showNotification('✅ 모든 데이터가 초기화되었습니다.');
                }
            }
    
            function saveData() {
                const dataToSave = {
                    transactions: allTransactions,
                    customers: allCustomers,
                    uploadHistory: uploadHistory,
                    staffClassifications: staffClassifications,
                    timestamp: new Date().toISOString()
                };
                
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
                } catch (error) {
                    console.warn('데이터 저장 실패:', error);
                    showNotification('⚠️ 데이터가 너무 커서 저장하지 못했습니다.');
                }
            }
    
            function loadStoredData() {
                try {
                    const storedData = localStorage.getItem(STORAGE_KEY);
                    if (storedData) {
                        const data = JSON.parse(storedData);
                        
                        allTransactions = data.transactions || [];
                        allCustomers = data.customers || {};
                        uploadHistory = data.uploadHistory || [];
                        staffClassifications = data.staffClassifications || {};
                        
                        allTransactions.forEach(t => {
                            if (t.parsedDate) t.parsedDate = new Date(t.parsedDate);
                        });
                        
                        Object.values(allCustomers).forEach(customer => {
                            if (customer.firstTransactionDate) customer.firstTransactionDate = new Date(customer.firstTransactionDate);
                            if (customer.lastTransactionDate) customer.lastTransactionDate = new Date(customer.lastTransactionDate);
                            if(customer.transactions) {
                               customer.transactions.forEach(t => { if(t.parsedDate) t.parsedDate = new Date(t.parsedDate) });
                            }
                        });
                        
                        uploadHistory.forEach(upload => {
                            upload.uploadTime = new Date(upload.uploadTime);
                        });
                        
                        if (allTransactions.length > 0) {
                            analysisComplete = true;
                            updateAllTabs();
                            showNotification('💾 저장된 데이터를 불러왔습니다.');
                        }
                    }
                } catch (error) {
                    console.warn('저장된 데이터 로드 실패:', error);
                    showNotification('⚠️ 저장된 데이터를 불러오지 못했습니다.');
                }
            }
    
            function exportData() {
                if (!analysisComplete || allTransactions.length === 0) {
                    showNotification('❌ 먼저 데이터를 분석하세요!');
                    return;
                }
                
                const nonExcludedCustomers = Object.values(allCustomers).filter(c => !c.excluded);
                const totalDeposits = nonExcludedCustomers.reduce((sum, c) => sum + c.depositAmount, 0);
                const totalSales = nonExcludedCustomers.reduce((sum, c) => sum + c.salesAmount, 0);
                const excludedAmount = Object.values(allCustomers).filter(c => c.excluded).reduce((sum, c) => sum + c.totalIncome, 0);
                
                const exportData = {
                    timestamp: new Date().toISOString(),
                    summary: {
                        totalTransactions: allTransactions.length,
                        totalCustomers: Object.keys(allCustomers).length,
                        totalIncome: allTransactions.filter(t => t.type === '입금').reduce((sum, t) => sum + t.inAmount, 0),
                        totalSales: totalSales,
                        totalDeposits: totalDeposits,
                        excludedAmount: excludedAmount,
                    },
                    customers: Object.values(allCustomers)
                        .filter(c => !c.excluded)
                        .map(c => ({
                            name: c.name,
                            totalIncome: c.totalIncome,
                            depositAmount: c.depositAmount,
                            salesAmount: c.salesAmount,
                            depositStatus: c.depositStatus,
                            transactionCount: c.transactions.filter(t => t.type === '입금').length
                        }))
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `까사트레이드_계좌분석_${new Date().toISOString().substring(0, 10)}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                showNotification('✅ 분석 결과(JSON)가 내보내졌습니다!');
            }
    
            function showNotification(message) {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.classList.add('show');
                setTimeout(() => notification.classList.remove('show'), 3000);
            }
    
            function showProgress(percentage, message) {
                document.getElementById('progressContainer').style.display = 'block';
                document.getElementById('progressFill').style.width = percentage + '%';
                document.getElementById('processStatus').textContent = message;
            }
    
            function hideProgress() {
                setTimeout(() => {
                    document.getElementById('progressContainer').style.display = 'none';
                    document.getElementById('processStatus').textContent = '';
                }, 1000);
            }   
    </script>
</body>
</html>
